// src/lib/storage/service.ts
import { createClient } from '@/lib/supabase/server'
import { z } from 'zod'

// File metadata schema
export const fileMetadataSchema = z.object({
  name: z.string(),
  size: z.number(),
  type: z.string(),
  folder_id: z.string().optional(),
  tags: z.array(z.string()).optional(),
  description: z.string().optional(),
})

export interface StorageFile {
  id: string
  name: string
  size: number
  type: string
  path: string
  url?: string
  folder_id?: string
  user_id: string
  organization_id?: string
  tags?: string[]
  description?: string
  created_at: string
  updated_at: string
}

export interface StorageFolder {
  id: string
  name: string
  parent_id?: string
  user_id: string
  organization_id?: string
  created_at: string
  updated_at: string
}

export interface StorageQuota {
  used: number
  limit: number
  percentage: number
}

export class StorageService {
  static readonly BUCKET_NAME = 'user-files'
  static readonly PUBLIC_BUCKET_NAME = 'public-files'
  
  // File size limits by plan
  static readonly FILE_SIZE_LIMITS = {
    free: 10 * 1024 * 1024, // 10MB
    pro: 100 * 1024 * 1024, // 100MB
    enterprise: 1024 * 1024 * 1024, // 1GB
  }

  // Storage limits by plan
  static readonly STORAGE_LIMITS = {
    free: 100 * 1024 * 1024, // 100MB
    pro: 10 * 1024 * 1024 * 1024, // 10GB
    enterprise: -1, // Unlimited
  }

  // Upload file
  static async uploadFile(
    file: File,
    options: {
      userId: string
      organizationId?: string
      folderId?: string
      isPublic?: boolean
      metadata?: Partial<z.infer<typeof fileMetadataSchema>>
    }
  ) {
    const supabase = createClient()
    
    // Check file size limit
    const userTier = await this.getUserTier(options.userId)
    const sizeLimit = this.FILE_SIZE_LIMITS[userTier]
    
    if (file.size > sizeLimit) {
      throw new Error(`File size exceeds limit of ${this.formatBytes(sizeLimit)}`)
    }

    // Check storage quota
    const quota = await this.getStorageQuota(options.userId, options.organizationId)
    if (quota.limit !== -1 && quota.used + file.size > quota.limit) {
      throw new Error('Storage quota exceeded')
    }

    // Generate unique file path
    const fileExt = file.name.split('.').pop()
    const fileName = `${crypto.randomUUID()}.${fileExt}`
    const filePath = options.organizationId
      ? `organizations/${options.organizationId}/${fileName}`
      : `users/${options.userId}/${fileName}`

    // Upload to Supabase Storage
    const bucket = options.isPublic ? this.PUBLIC_BUCKET_NAME : this.BUCKET_NAME
    const { data: uploadData, error: uploadError } = await supabase.storage
      .from(bucket)
      .upload(filePath, file)

    if (uploadError) {
      throw new Error(`Upload failed: ${uploadError.message}`)
    }

    // Get public URL if needed
    let publicUrl: string | undefined
    if (options.isPublic) {
      const { data } = supabase.storage
        .from(bucket)
        .getPublicUrl(filePath)
      publicUrl = data.publicUrl
    }

    // Save file metadata to database
    const { data: fileRecord, error: dbError } = await supabase
      .from('files')
      .insert({
        name: file.name,
        size: file.size,
        type: file.type,
        path: filePath,
        url: publicUrl,
        folder_id: options.folderId,
        user_id: options.userId,
        organization_id: options.organizationId,
        tags: options.metadata?.tags,
        description: options.metadata?.description,
        is_public: options.isPublic || false,
      })
      .select()
      .single()

    if (dbError) {
      // Rollback storage upload
      await supabase.storage.from(bucket).remove([filePath])
      throw new Error(`Failed to save file metadata: ${dbError.message}`)
    }

    return fileRecord
  }

  // Get file by ID
  static async getFile(fileId: string, userId: string) {
    const supabase = createClient()
    
    const { data, error } = await supabase
      .from('files')
      .select('*')
      .eq('id', fileId)
      .single()

    if (error) {
      throw new Error(`File not found: ${error.message}`)
    }

    // Check permissions
    if (!await this.canAccessFile(data, userId)) {
      throw new Error('Access denied')
    }

    return data
  }

  // List files
  static async listFiles(options: {
    userId: string
    organizationId?: string
    folderId?: string
    search?: string
    tags?: string[]
    limit?: number
    offset?: number
  }) {
    const supabase = createClient()
    
    let query = supabase
      .from('files')
      .select('*', { count: 'exact' })

    // Filter by ownership
    if (options.organizationId) {
      query = query.eq('organization_id', options.organizationId)
    } else {
      query = query.eq('user_id', options.userId)
    }

    // Filter by folder
    if (options.folderId !== undefined) {
      query = query.eq('folder_id', options.folderId)
    }

    // Search
    if (options.search) {
      query = query.ilike('name', `%${options.search}%`)
    }

    // Filter by tags
    if (options.tags && options.tags.length > 0) {
      query = query.contains('tags', options.tags)
    }

    // Pagination
    const limit = options.limit || 50
    const offset = options.offset || 0
    query = query.range(offset, offset + limit - 1)

    // Order by created date
    query = query.order('created_at', { ascending: false })

    const { data, error, count } = await query

    if (error) {
      throw new Error(`Failed to list files: ${error.message}`)
    }

    return {
      files: data || [],
      total: count || 0,
      limit,
      offset,
    }
  }

  // Download file
  static async downloadFile(fileId: string, userId: string) {
    const file = await this.getFile(fileId, userId)
    const supabase = createClient()
    
    // Generate signed URL for private files
    if (!file.is_public) {
      const { data, error } = await supabase.storage
        .from(this.BUCKET_NAME)
        .createSignedUrl(file.path, 3600) // 1 hour expiry

      if (error) {
        throw new Error(`Failed to generate download URL: ${error.message}`)
      }

      return { url: data.signedUrl, filename: file.name }
    }

    // Return public URL
    return { url: file.url, filename: file.name }
  }

  // Delete file
  static async deleteFile(fileId: string, userId: string) {
    const supabase = createClient()
    const file = await this.getFile(fileId, userId)

    // Check permissions
    if (!await this.canDeleteFile(file, userId)) {
      throw new Error('Access denied')
    }

    // Delete from storage
    const bucket = file.is_public ? this.PUBLIC_BUCKET_NAME : this.BUCKET_NAME
    const { error: storageError } = await supabase.storage
      .from(bucket)
      .remove([file.path])

    if (storageError) {
      throw new Error(`Failed to delete file: ${storageError.message}`)
    }

    // Delete from database
    const { error: dbError } = await supabase
      .from('files')
      .delete()
      .eq('id', fileId)

    if (dbError) {
      throw new Error(`Failed to delete file record: ${dbError.message}`)
    }

    return { success: true }
  }

  // Create folder
  static async createFolder(data: {
    name: string
    parentId?: string
    userId: string
    organizationId?: string
  }) {
    const supabase = createClient()
    
    const { data: folder, error } = await supabase
      .from('folders')
      .insert({
        name: data.name,
        parent_id: data.parentId,
        user_id: data.userId,
        organization_id: data.organizationId,
      })
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to create folder: ${error.message}`)
    }

    return folder
  }

  // List folders
  static async listFolders(options: {
    userId: string
    organizationId?: string
    parentId?: string
  }) {
    const supabase = createClient()
    
    let query = supabase
      .from('folders')
      .select('*')

    // Filter by ownership
    if (options.organizationId) {
      query = query.eq('organization_id', options.organizationId)
    } else {
      query = query.eq('user_id', options.userId)
    }

    // Filter by parent
    if (options.parentId !== undefined) {
      query = query.eq('parent_id', options.parentId)
    }

    const { data, error } = await query.order('name')

    if (error) {
      throw new Error(`Failed to list folders: ${error.message}`)
    }

    return data || []
  }

  // Move file to folder
  static async moveFile(fileId: string, folderId: string | null, userId: string) {
    const supabase = createClient()
    const file = await this.getFile(fileId, userId)

    // Check permissions
    if (!await this.canAccessFile(file, userId)) {
      throw new Error('Access denied')
    }

    const { error } = await supabase
      .from('files')
      .update({ folder_id: folderId })
      .eq('id', fileId)

    if (error) {
      throw new Error(`Failed to move file: ${error.message}`)
    }

    return { success: true }
  }

  // Get storage quota
  static async getStorageQuota(userId: string, organizationId?: string): Promise<StorageQuota> {
    const supabase = createClient()
    
    // Get user tier
    const tier = await this.getUserTier(userId)
    const limit = this.STORAGE_LIMITS[tier]

    // Calculate used storage
    let query = supabase
      .from('files')
      .select('size')

    if (organizationId) {
      query = query.eq('organization_id', organizationId)
    } else {
      query = query.eq('user_id', userId)
    }

    const { data } = await query
    const used = data?.reduce((total, file) => total + file.size, 0) || 0

    return {
      used,
      limit,
      percentage: limit === -1 ? 0 : Math.round((used / limit) * 100),
    }
  }

  // Share file
  static async shareFile(fileId: string, options: {
    userId: string
    expiresIn?: number // hours
    password?: string
  }) {
    const supabase = createClient()
    const file = await this.getFile(fileId, options.userId)

    // Generate share token
    const token = crypto.randomUUID()
    const expiresAt = new Date()
    expiresAt.setHours(expiresAt.getHours() + (options.expiresIn || 24))

    const { data, error } = await supabase
      .from('file_shares')
      .insert({
        file_id: fileId,
        token,
        expires_at: expiresAt.toISOString(),
        password_hash: options.password ? await this.hashPassword(options.password) : null,
        created_by: options.userId,
      })
      .select()
      .single()

    if (error) {
      throw new Error(`Failed to create share link: ${error.message}`)
    }

    return {
      shareUrl: `${process.env.NEXT_PUBLIC_APP_URL}/shared/${token}`,
      token,
      expiresAt: data.expires_at,
    }
  }

  // Access shared file
  static async accessSharedFile(token: string, password?: string) {
    const supabase = createClient()
    
    const { data: share, error } = await supabase
      .from('file_shares')
      .select('*, file:files(*)')
      .eq('token', token)
      .gte('expires_at', new Date().toISOString())
      .single()

    if (error || !share) {
      throw new Error('Invalid or expired share link')
    }

    // Check password if required
    if (share.password_hash && !password) {
      throw new Error('Password required')
    }

    if (share.password_hash && password) {
      const isValid = await this.verifyPassword(password, share.password_hash)
      if (!isValid) {
        throw new Error('Invalid password')
      }
    }

    // Increment access count
    await supabase
      .from('file_shares')
      .update({ access_count: share.access_count + 1 })
      .eq('id', share.id)

    return share.file
  }

  // Helper methods
  private static async getUserTier(userId: string): Promise<'free' | 'pro' | 'enterprise'> {
    const supabase = createClient()
    
    const { data } = await supabase
      .from('subscriptions')
      .select('stripe_price_id')
      .eq('user_id', userId)
      .eq('status', 'ACTIVE')
      .single()

    if (!data) return 'free'

    // Map price IDs to tiers
    if (data.stripe_price_id === process.env.NEXT_PUBLIC_STRIPE_PRO_PRICE_ID) {
      return 'pro'
    }
    
    // Add more tier mappings as needed
    return 'free'
  }

  private static async canAccessFile(file: any, userId: string): Promise<boolean> {
    // User owns the file
    if (file.user_id === userId) return true

    // Check organization membership
    if (file.organization_id) {
      const supabase = createClient()
      const { data } = await supabase
        .from('organization_members')
        .select('id')
        .eq('organization_id', file.organization_id)
        .eq('user_id', userId)
        .single()

      return !!data
    }

    return false
  }

  private static async canDeleteFile(file: any, userId: string): Promise<boolean> {
    // For now, same as access permissions
    // Could add more complex logic here
    return this.canAccessFile(file, userId)
  }

  private static formatBytes(bytes: number): string {
    if (bytes === 0) return '0 Bytes'
    const k = 1024
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
  }

  private static async hashPassword(password: string): Promise<string> {
    // In a real app, use bcrypt or similar
    // This is a placeholder
    const encoder = new TextEncoder()
    const data = encoder.encode(password)
    const hash = await crypto.subtle.digest('SHA-256', data)
    return btoa(String.fromCharCode(...new Uint8Array(hash)))
  }

  private static async verifyPassword(password: string, hash: string): Promise<boolean> {
    const passwordHash = await this.hashPassword(password)
    return passwordHash === hash
  }
}






// src/hooks/use-storage.ts
'use client'

import { useState, useCallback } from 'react'
import { createClient } from '@/lib/supabase/client'
import { useAuth } from './use-auth'
import { useOrganization } from './use-organization'

interface UploadOptions {
  folderId?: string
  isPublic?: boolean
  metadata?: {
    tags?: string[]
    description?: string
  }
  onProgress?: (progress: number) => void
}

interface StorageFile {
  id: string
  name: string
  size: number
  type: string
  path: string
  url?: string
  folder_id?: string
  user_id: string
  organization_id?: string
  tags?: string[]
  description?: string
  created_at: string
  updated_at: string
}

export function useStorage() {
  const { user } = useAuth()
  const { organization } = useOrganization()
  const [uploading, setUploading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const supabase = createClient()

  const upload = useCallback(
    async (file: File, options: UploadOptions = {}) => {
      if (!user) throw new Error('Not authenticated')

      setUploading(true)
      setError(null)

      try {
        // Create form data
        const formData = new FormData()
        formData.append('file', file)
        formData.append('userId', user.id)
        if (organization?.id) {
          formData.append('organizationId', organization.id)
        }
        if (options.folderId) {
          formData.append('folderId', options.folderId)
        }
        if (options.isPublic) {
          formData.append('isPublic', 'true')
        }
        if (options.metadata) {
          formData.append('metadata', JSON.stringify(options.metadata))
        }

        const response = await fetch('/api/storage/upload', {
          method: 'POST',
          body: formData,
        })

        const data = await response.json()

        if (!response.ok) {
          throw new Error(data.error || 'Upload failed')
        }

        return data
      } catch (err: any) {
        setError(err.message)
        throw err
      } finally {
        setUploading(false)
      }
    },
    [user, organization]
  )

  const deleteFile = useCallback(
    async (fileId: string) => {
      if (!user) throw new Error('Not authenticated')

      setError(null)

      try {
        const response = await fetch(`/api/storage/files/${fileId}`, {
          method: 'DELETE',
        })

        const data = await response.json()

        if (!response.ok) {
          throw new Error(data.error || 'Delete failed')
        }

        return data
      } catch (err: any) {
        setError(err.message)
        throw err
      }
    },
    [user]
  )

  const downloadFile = useCallback(
    async (fileId: string) => {
      if (!user) throw new Error('Not authenticated')

      setError(null)

      try {
        const response = await fetch(`/api/storage/files/${fileId}/download`)
        const data = await response.json()

        if (!response.ok) {
          throw new Error(data.error || 'Download failed')
        }

        // Open download URL
        window.open(data.url, '_blank')
        
        return data
      } catch (err: any) {
        setError(err.message)
        throw err
      }
    },
    [user]
  )

  const shareFile = useCallback(
    async (fileId: string, options?: { expiresIn?: number; password?: string }) => {
      if (!user) throw new Error('Not authenticated')

      setError(null)

      try {
        const response = await fetch(`/api/storage/files/${fileId}/share`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(options || {}),
        })

        const data = await response.json()

        if (!response.ok) {
          throw new Error(data.error || 'Share failed')
        }

        return data
      } catch (err: any) {
        setError(err.message)
        throw err
      }
    },
    [user]
  )

  return {
    upload,
    deleteFile,
    downloadFile,
    shareFile,
    uploading,
    error,
  }
}

// src/hooks/use-files.ts
'use client'

import { useEffect, useState, useCallback } from 'react'
import { useAuth } from './use-auth'
import { useOrganization } from './use-organization'
import { createClient } from '@/lib/supabase/client'

interface UseFilesOptions {
  folderId?: string
  search?: string
  tags?: string[]
  limit?: number
}

interface StorageFile {
  id: string
  name: string
  size: number
  type: string
  path: string
  url?: string
  folder_id?: string
  user_id: string
  organization_id?: string
  tags?: string[]
  description?: string
  created_at: string
  updated_at: string
}

interface StorageFolder {
  id: string
  name: string
  parent_id?: string
  user_id: string
  organization_id?: string
  created_at: string
  updated_at: string
}

export function useFiles(options: UseFilesOptions = {}) {
  const { user } = useAuth()
  const { organization } = useOrganization()
  const [files, setFiles] = useState<StorageFile[]>([])
  const [folders, setFolders] = useState<StorageFolder[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [total, setTotal] = useState(0)
  const [offset, setOffset] = useState(0)

  const fetchFiles = useCallback(async () => {
    if (!user) return

    setLoading(true)
    setError(null)

    try {
      const params = new URLSearchParams({
        ...(organization?.id && { organizationId: organization.id }),
        ...(options.folderId && { folderId: options.folderId }),
        ...(options.search && { search: options.search }),
        ...(options.tags && { tags: options.tags.join(',') }),
        limit: String(options.limit || 50),
        offset: String(offset),
      })

      const response = await fetch(`/api/storage/files?${params}`)
      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Failed to fetch files')
      }

      setFiles(data.files)
      setTotal(data.total)
    } catch (err: any) {
      setError(err.message)
    } finally {
      setLoading(false)
    }
  }, [user, organization, options, offset])

  const fetchFolders = useCallback(async () => {
    if (!user) return

    try {
      const params = new URLSearchParams({
        ...(organization?.id && { organizationId: organization.id }),
        ...(options.folderId && { parentId: options.folderId }),
      })

      const response = await fetch(`/api/storage/folders?${params}`)
      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Failed to fetch folders')
      }

      setFolders(data)
    } catch (err: any) {
      console.error('Failed to fetch folders:', err)
    }
  }, [user, organization, options.folderId])

  useEffect(() => {
    if (user) {
      fetchFiles()
      fetchFolders()
    }
  }, [user, fetchFiles, fetchFolders])

  const createFolder = async (name: string) => {
    if (!user) throw new Error('Not authenticated')

    try {
      const response = await fetch('/api/storage/folders', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name,
          parentId: options.folderId,
          organizationId: organization?.id,
        }),
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Failed to create folder')
      }

      await fetchFolders()
      return data
    } catch (err: any) {
      throw err
    }
  }

  const moveFile = async (fileId: string, targetFolderId: string | null) => {
    if (!user) throw new Error('Not authenticated')

    try {
      const response = await fetch(`/api/storage/files/${fileId}/move`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ folderId: targetFolderId }),
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Failed to move file')
      }

      await fetchFiles()
      return data
    } catch (err: any) {
      throw err
    }
  }

  const refresh = () => {
    fetchFiles()
    fetchFolders()
  }

  const loadMore = () => {
    if (files.length < total) {
      setOffset(offset + (options.limit || 50))
    }
  }

  return {
    files,
    folders,
    loading,
    error,
    total,
    hasMore: files.length < total,
    createFolder,
    moveFile,
    refresh,
    loadMore,
  }
}

// src/hooks/use-storage-quota.ts
'use client'

import { useEffect, useState } from 'react'
import { useAuth } from './use-auth'
import { useOrganization } from './use-organization'

interface StorageQuota {
  used: number
  limit: number
  percentage: number
}

export function useStorageQuota() {
  const { user } = useAuth()
  const { organization } = useOrganization()
  const [quota, setQuota] = useState<StorageQuota | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    if (user) {
      fetchQuota()
    }
  }, [user, organization])

  const fetchQuota = async () => {
    if (!user) return

    setLoading(true)
    try {
      const params = new URLSearchParams({
        ...(organization?.id && { organizationId: organization.id }),
      })

      const response = await fetch(`/api/storage/quota?${params}`)
      const data = await response.json()

      if (response.ok) {
        setQuota(data)
      }
    } catch (error) {
      console.error('Failed to fetch quota:', error)
    } finally {
      setLoading(false)
    }
  }

  const formatBytes = (bytes: number): string => {
    if (bytes === 0) return '0 Bytes'
    const k = 1024
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
  }

  return {
    quota,
    loading,
    refreshQuota: fetchQuota,
    formatBytes,
    isUnlimited: quota?.limit === -1,
    isNearLimit: quota ? quota.percentage >= 80 : false,
    isAtLimit: quota ? quota.percentage >= 100 : false,
  }
}






// src/app/api/storage/upload/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { StorageService } from '@/lib/storage/service'

export async function POST(request: NextRequest) {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const formData = await request.formData()
    const file = formData.get('file') as File
    const userId = formData.get('userId') as string
    const organizationId = formData.get('organizationId') as string | undefined
    const folderId = formData.get('folderId') as string | undefined
    const isPublic = formData.get('isPublic') === 'true'
    const metadata = formData.get('metadata') as string | undefined

    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 })
    }

    // Verify user ID matches
    if (userId !== user.id) {
      return NextResponse.json({ error: 'User mismatch' }, { status: 403 })
    }

    const fileRecord = await StorageService.uploadFile(file, {
      userId,
      organizationId,
      folderId,
      isPublic,
      metadata: metadata ? JSON.parse(metadata) : undefined,
    })

    return NextResponse.json(fileRecord)
  } catch (error: any) {
    console.error('Upload error:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

// src/app/api/storage/files/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { StorageService } from '@/lib/storage/service'

export async function GET(request: NextRequest) {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const searchParams = request.nextUrl.searchParams
    const organizationId = searchParams.get('organizationId') || undefined
    const folderId = searchParams.get('folderId') || undefined
    const search = searchParams.get('search') || undefined
    const tags = searchParams.get('tags')?.split(',').filter(Boolean) || undefined
    const limit = parseInt(searchParams.get('limit') || '50')
    const offset = parseInt(searchParams.get('offset') || '0')

    const result = await StorageService.listFiles({
      userId: user.id,
      organizationId,
      folderId,
      search,
      tags,
      limit,
      offset,
    })

    return NextResponse.json(result)
  } catch (error: any) {
    console.error('List files error:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

// src/app/api/storage/files/[fileId]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { StorageService } from '@/lib/storage/service'

interface Params {
  params: { fileId: string }
}

export async function GET(request: NextRequest, { params }: Params) {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const file = await StorageService.getFile(params.fileId, user.id)
    return NextResponse.json(file)
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function DELETE(request: NextRequest, { params }: Params) {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const result = await StorageService.deleteFile(params.fileId, user.id)
    return NextResponse.json(result)
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

// src/app/api/storage/files/[fileId]/download/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { StorageService } from '@/lib/storage/service'

interface Params {
  params: { fileId: string }
}

export async function GET(request: NextRequest, { params }: Params) {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const result = await StorageService.downloadFile(params.fileId, user.id)
    return NextResponse.json(result)
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

// src/app/api/storage/files/[fileId]/share/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { StorageService } from '@/lib/storage/service'
import { z } from 'zod'

interface Params {
  params: { fileId: string }
}

const shareSchema = z.object({
  expiresIn: z.number().optional(),
  password: z.string().optional(),
})

export async function POST(request: NextRequest, { params }: Params) {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const options = shareSchema.parse(body)

    const result = await StorageService.shareFile(params.fileId, {
      userId: user.id,
      ...options,
    })

    return NextResponse.json(result)
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors[0].message }, { status: 400 })
    }
    
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

// src/app/api/storage/files/[fileId]/move/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { StorageService } from '@/lib/storage/service'
import { z } from 'zod'

interface Params {
  params: { fileId: string }
}

const moveSchema = z.object({
  folderId: z.string().nullable(),
})

export async function PATCH(request: NextRequest, { params }: Params) {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { folderId } = moveSchema.parse(body)

    const result = await StorageService.moveFile(params.fileId, folderId, user.id)
    return NextResponse.json(result)
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors[0].message }, { status: 400 })
    }
    
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

// src/app/api/storage/folders/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { StorageService } from '@/lib/storage/service'
import { z } from 'zod'

const createFolderSchema = z.object({
  name: z.string().min(1),
  parentId: z.string().optional(),
  organizationId: z.string().optional(),
})

export async function GET(request: NextRequest) {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const searchParams = request.nextUrl.searchParams
    const organizationId = searchParams.get('organizationId') || undefined
    const parentId = searchParams.get('parentId') || undefined

    const folders = await StorageService.listFolders({
      userId: user.id,
      organizationId,
      parentId,
    })

    return NextResponse.json(folders)
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const data = createFolderSchema.parse(body)

    const folder = await StorageService.createFolder({
      ...data,
      userId: user.id,
    })

    return NextResponse.json(folder)
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors[0].message }, { status: 400 })
    }
    
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

// src/app/api/storage/quota/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { StorageService } from '@/lib/storage/service'

export async function GET(request: NextRequest) {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const searchParams = request.nextUrl.searchParams
    const organizationId = searchParams.get('organizationId') || undefined

    const quota = await StorageService.getStorageQuota(user.id, organizationId)
    return NextResponse.json(quota)
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

// src/app/api/shared/[token]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { StorageService } from '@/lib/storage/service'
import { z } from 'zod'

interface Params {
  params: { token: string }
}

const accessSchema = z.object({
  password: z.string().optional(),
})

export async function POST(request: NextRequest, { params }: Params) {
  try {
    const body = await request.json()
    const { password } = accessSchema.parse(body)

    const file = await StorageService.accessSharedFile(params.token, password)
    return NextResponse.json(file)
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors[0].message }, { status: 400 })
    }
    
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}





-- supabase/migrations/20240104000000_create_storage_tables.sql

-- Create folders table
CREATE TABLE IF NOT EXISTS folders (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  parent_id UUID REFERENCES folders(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create files table
CREATE TABLE IF NOT EXISTS files (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  size BIGINT NOT NULL,
  type VARCHAR(255) NOT NULL,
  path TEXT NOT NULL,
  url TEXT,
  folder_id UUID REFERENCES folders(id) ON DELETE SET NULL,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  tags TEXT[] DEFAULT '{}',
  description TEXT,
  is_public BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create file shares table
CREATE TABLE IF NOT EXISTS file_shares (
  id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
  file_id UUID NOT NULL REFERENCES files(id) ON DELETE CASCADE,
  token UUID DEFAULT uuid_generate_v4() NOT NULL UNIQUE,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  password_hash TEXT,
  access_count INTEGER DEFAULT 0,
  created_by UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes
CREATE INDEX idx_folders_user_id ON folders(user_id);
CREATE INDEX idx_folders_organization_id ON folders(organization_id);
CREATE INDEX idx_folders_parent_id ON folders(parent_id);

CREATE INDEX idx_files_user_id ON files(user_id);
CREATE INDEX idx_files_organization_id ON files(organization_id);
CREATE INDEX idx_files_folder_id ON files(folder_id);
CREATE INDEX idx_files_created_at ON files(created_at);
CREATE INDEX idx_files_tags ON files USING GIN(tags);

CREATE INDEX idx_file_shares_token ON file_shares(token);
CREATE INDEX idx_file_shares_file_id ON file_shares(file_id);
CREATE INDEX idx_file_shares_expires_at ON file_shares(expires_at);

-- Create updated_at triggers
CREATE TRIGGER update_folders_updated_at
  BEFORE UPDATE ON folders
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_files_updated_at
  BEFORE UPDATE ON files
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Add RLS policies for folders
ALTER TABLE folders ENABLE ROW LEVEL SECURITY;

-- Users can view their own folders
CREATE POLICY "Users can view own folders" ON folders
  FOR SELECT USING (
    user_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM organization_members
      WHERE organization_members.organization_id = folders.organization_id
      AND organization_members.user_id = auth.uid()
    )
  );

-- Users can create folders
CREATE POLICY "Users can create folders" ON folders
  FOR INSERT WITH CHECK (
    user_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM organization_members
      WHERE organization_members.organization_id = folders.organization_id
      AND organization_members.user_id = auth.uid()
    )
  );

-- Users can update their own folders
CREATE POLICY "Users can update own folders" ON folders
  FOR UPDATE USING (
    user_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM organization_members
      WHERE organization_members.organization_id = folders.organization_id
      AND organization_members.user_id = auth.uid()
    )
  );

-- Users can delete their own folders
CREATE POLICY "Users can delete own folders" ON folders
  FOR DELETE USING (
    user_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM organization_members
      WHERE organization_members.organization_id = folders.organization_id
      AND organization_members.user_id = auth.uid()
      AND organization_members.role IN ('ADMIN', 'OWNER')
    )
  );

-- Add RLS policies for files
ALTER TABLE files ENABLE ROW LEVEL SECURITY;

-- Users can view their own files or public files
CREATE POLICY "Users can view files" ON files
  FOR SELECT USING (
    is_public = true OR
    user_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM organization_members
      WHERE organization_members.organization_id = files.organization_id
      AND organization_members.user_id = auth.uid()
    )
  );

-- Users can create files
CREATE POLICY "Users can create files" ON files
  FOR INSERT WITH CHECK (
    user_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM organization_members
      WHERE organization_members.organization_id = files.organization_id
      AND organization_members.user_id = auth.uid()
    )
  );

-- Users can update their own files
CREATE POLICY "Users can update own files" ON files
  FOR UPDATE USING (
    user_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM organization_members
      WHERE organization_members.organization_id = files.organization_id
      AND organization_members.user_id = auth.uid()
    )
  );

-- Users can delete their own files
CREATE POLICY "Users can delete own files" ON files
  FOR DELETE USING (
    user_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM organization_members
      WHERE organization_members.organization_id = files.organization_id
      AND organization_members.user_id = auth.uid()
      AND organization_members.role IN ('ADMIN', 'OWNER')
    )
  );

-- Add RLS policies for file_shares
ALTER TABLE file_shares ENABLE ROW LEVEL SECURITY;

-- Only file owners can create/view shares
CREATE POLICY "File owners can manage shares" ON file_shares
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM files
      WHERE files.id = file_shares.file_id
      AND (
        files.user_id = auth.uid() OR
        EXISTS (
          SELECT 1 FROM organization_members
          WHERE organization_members.organization_id = files.organization_id
          AND organization_members.user_id = auth.uid()
        )
      )
    )
  );

-- Create storage buckets
INSERT INTO storage.buckets (id, name, public)
VALUES 
  ('user-files', 'user-files', false),
  ('public-files', 'public-files', true)
ON CONFLICT (id) DO NOTHING;

-- Set up storage policies
CREATE POLICY "Users can upload files" ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'user-files' AND
    auth.role() = 'authenticated'
  );

CREATE POLICY "Users can view own files" ON storage.objects
  FOR SELECT USING (
    bucket_id = 'user-files' AND
    auth.role() = 'authenticated' AND
    (storage.foldername(name))[1] = 'users' AND
    (storage.foldername(name))[2] = auth.uid()::text
  );

CREATE POLICY "Users can delete own files" ON storage.objects
  FOR DELETE USING (
    bucket_id = 'user-files' AND
    auth.role() = 'authenticated' AND
    (storage.foldername(name))[1] = 'users' AND
    (storage.foldername(name))[2] = auth.uid()::text
  );

-- Public files policies
CREATE POLICY "Anyone can view public files" ON storage.objects
  FOR SELECT USING (bucket_id = 'public-files');

CREATE POLICY "Authenticated users can upload public files" ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'public-files' AND
    auth.role() = 'authenticated'
  );

-- Function to calculate storage usage
CREATE OR REPLACE FUNCTION get_storage_usage(p_user_id UUID, p_organization_id UUID DEFAULT NULL)
RETURNS BIGINT AS $$
BEGIN
  RETURN COALESCE(
    (
      SELECT SUM(size)
      FROM files
      WHERE (
        (p_organization_id IS NOT NULL AND organization_id = p_organization_id) OR
        (p_organization_id IS NULL AND user_id = p_user_id AND organization_id IS NULL)
      )
    ),
    0
  );
END;
$$ LANGUAGE plpgsql;

-- Function to clean expired shares
CREATE OR REPLACE FUNCTION clean_expired_shares()
RETURNS void AS $$
BEGIN
  DELETE FROM file_shares
  WHERE expires_at < NOW();
END;
$$ LANGUAGE plpgsql;







// src/app/(dashboard)/files/page.tsx
'use client'

import { useState } from 'react'
import { FileManager } from '@/components/storage/file-manager'
import { StorageQuota } from '@/components/storage/storage-quota'
import { UploadButton } from '@/components/storage/upload-button'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'

export default function FilesPage() {
  const [currentFolder, setCurrentFolder] = useState<string | undefined>()

  return (
    <div className="space-y-8">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold">Files</h1>
          <p className="text-gray-600 mt-2">
            Manage your files and documents
          </p>
        </div>
        <UploadButton folderId={currentFolder} />
      </div>

      <StorageQuota />

      <Tabs defaultValue="all" className="w-full">
        <TabsList>
          <TabsTrigger value="all">All Files</TabsTrigger>
          <TabsTrigger value="recent">Recent</TabsTrigger>
          <TabsTrigger value="shared">Shared</TabsTrigger>
        </TabsList>

        <TabsContent value="all" className="mt-6">
          <FileManager 
            currentFolder={currentFolder}
            onFolderChange={setCurrentFolder}
          />
        </TabsContent>

        <TabsContent value="recent" className="mt-6">
          <FileManager 
            currentFolder={currentFolder}
            onFolderChange={setCurrentFolder}
            sortBy="recent"
          />
        </TabsContent>

        <TabsContent value="shared" className="mt-6">
          <Card>
            <CardHeader>
              <CardTitle>Shared Files</CardTitle>
              <CardDescription>
                Files you've shared with others
              </CardDescription>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-gray-500 text-center py-8">
                Shared files will appear here
              </p>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  )
}

// src/components/storage/file-manager.tsx
'use client'

import { useState } from 'react'
import { useFiles } from '@/hooks/use-files'
import { useStorage } from '@/hooks/use-storage'
import { FileGrid } from './file-grid'
import { FileList } from './file-list'
import { FolderBreadcrumb } from './folder-breadcrumb'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Icons } from '@/components/ui/icons'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import { Alert, AlertDescription } from '@/components/ui/alert'

interface FileManagerProps {
  currentFolder?: string
  onFolderChange: (folderId: string | undefined) => void
  sortBy?: 'recent' | 'name' | 'size'
}

export function FileManager({ currentFolder, onFolderChange, sortBy }: FileManagerProps) {
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid')
  const [search, setSearch] = useState('')
  const { files, folders, loading, error, refresh } = useFiles({
    folderId: currentFolder,
    search,
  })
  const { deleteFile } = useStorage()

  const handleDelete = async (fileId: string) => {
    if (!confirm('Are you sure you want to delete this file?')) {
      return
    }

    try {
      await deleteFile(fileId)
      refresh()
    } catch (error) {
      console.error('Failed to delete file:', error)
    }
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center py-16">
        <Icons.spinner className="h-8 w-8 animate-spin text-gray-400" />
      </div>
    )
  }

  if (error) {
    return (
      <Alert variant="destructive">
        <AlertDescription>{error}</AlertDescription>
      </Alert>
    )
  }

  return (
    <div className="space-y-4">
      {/* Toolbar */}
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-2">
          <Input
            placeholder="Search files..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            className="w-64"
            icon={<Icons.search className="h-4 w-4" />}
          />
        </div>

        <div className="flex items-center space-x-2">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => setViewMode('grid')}
            className={viewMode === 'grid' ? 'bg-gray-100' : ''}
          >
            <Icons.grid className="h-4 w-4" />
          </Button>
          <Button
            variant="ghost"
            size="sm"
            onClick={() => setViewMode('list')}
            className={viewMode === 'list' ? 'bg-gray-100' : ''}
          >
            <Icons.list className="h-4 w-4" />
          </Button>

          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="sm">
                <Icons.sort className="h-4 w-4 mr-2" />
                Sort
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem>Name</DropdownMenuItem>
              <DropdownMenuItem>Date modified</DropdownMenuItem>
              <DropdownMenuItem>Size</DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>

      {/* Breadcrumb */}
      <FolderBreadcrumb
        currentFolder={currentFolder}
        onNavigate={onFolderChange}
      />

      {/* Files and folders */}
      {viewMode === 'grid' ? (
        <FileGrid
          files={files}
          folders={folders}
          onFolderClick={onFolderChange}
          onDelete={handleDelete}
        />
      ) : (
        <FileList
          files={files}
          folders={folders}
          onFolderClick={onFolderChange}
          onDelete={handleDelete}
        />
      )}

      {files.length === 0 && folders.length === 0 && (
        <div className="text-center py-16">
          <Icons.folder className="h-12 w-12 text-gray-400 mx-auto mb-4" />
          <p className="text-gray-500">No files or folders</p>
        </div>
      )}
    </div>
  )
}

// src/components/storage/storage-quota.tsx
'use client'

import { useStorageQuota } from '@/hooks/use-storage-quota'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Progress } from '@/components/ui/progress'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { Icons } from '@/components/ui/icons'

export function StorageQuota() {
  const { quota, loading, formatBytes, isUnlimited, isNearLimit, isAtLimit } = useStorageQuota()

  if (loading || !quota) {
    return null
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-base">Storage Usage</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-2">
          <div className="flex items-center justify-between text-sm">
            <span>{formatBytes(quota.used)} used</span>
            <span>
              {isUnlimited ? 'Unlimited' : formatBytes(quota.limit)}
            </span>
          </div>
          
          {!isUnlimited && (
            <Progress 
              value={quota.percentage} 
              className={
                isAtLimit ? 'bg-red-100' : 
                isNearLimit ? 'bg-orange-100' : 
                ''
              }
            />
          )}

          {isAtLimit && (
            <Alert variant="destructive" className="mt-2">
              <Icons.alertCircle className="h-4 w-4" />
              <AlertDescription>
                You've reached your storage limit. Delete files or upgrade your plan.
              </AlertDescription>
            </Alert>
          )}

          {isNearLimit && !isAtLimit && (
            <Alert className="mt-2">
              <Icons.alertCircle className="h-4 w-4" />
              <AlertDescription>
                You're running low on storage. Consider upgrading your plan.
              </AlertDescription>
            </Alert>
          )}
        </div>
      </CardContent>
    </Card>
  )
}

// src/components/storage/upload-button.tsx
'use client'

import { useState, useRef } from 'react'
import { useStorage } from '@/hooks/use-storage'
import { useFiles } from '@/hooks/use-files'
import { Button } from '@/components/ui/button'
import { Icons } from '@/components/ui/icons'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { Progress } from '@/components/ui/progress'

interface UploadButtonProps {
  folderId?: string
}

export function UploadButton({ folderId }: UploadButtonProps) {
  const [showDialog, setShowDialog] = useState(false)
  const [uploadProgress, setUploadProgress] = useState(0)
  const [currentFile, setCurrentFile] = useState<string | null>(null)
  const fileInputRef = useRef<HTMLInputElement>(null)
  const { upload, uploading } = useStorage()
  const { refresh } = useFiles({ folderId })

  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = Array.from(e.target.files || [])
    if (files.length === 0) return

    setShowDialog(true)
    setUploadProgress(0)

    for (let i = 0; i < files.length; i++) {
      const file = files[i]
      setCurrentFile(file.name)
      setUploadProgress((i / files.length) * 100)

      try {
        await upload(file, {
          folderId,
          onProgress: (progress) => {
            setUploadProgress(((i + progress / 100) / files.length) * 100)
          },
        })
      } catch (error) {
        console.error(`Failed to upload ${file.name}:`, error)
      }
    }

    setUploadProgress(100)
    refresh()
    
    setTimeout(() => {
      setShowDialog(false)
      setCurrentFile(null)
      if (fileInputRef.current) {
        fileInputRef.current.value = ''
      }
    }, 1000)
  }

  return (
    <>
      <input
        ref={fileInputRef}
        type="file"
        multiple
        className="hidden"
        onChange={handleFileSelect}
      />
      
      <Button
        onClick={() => fileInputRef.current?.click()}
        disabled={uploading}
      >
        <Icons.upload className="h-4 w-4 mr-2" />
        Upload Files
      </Button>

      <Dialog open={showDialog} onOpenChange={setShowDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Uploading Files</DialogTitle>
            <DialogDescription>
              {currentFile ? `Uploading ${currentFile}...` : 'Preparing upload...'}
            </DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4">
            <Progress value={uploadProgress} />
            <p className="text-sm text-center text-gray-500">
              {Math.round(uploadProgress)}% complete
            </p>
          </div>
        </DialogContent>
      </Dialog>
    </>
  )
}






// src/components/storage/file-grid.tsx
'use client'

import { formatDistanceToNow } from 'date-fns'
import { FileIcon } from './file-icon'
import { Button } from '@/components/ui/button'
import { Icons } from '@/components/ui/icons'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'

interface FileGridProps {
  files: any[]
  folders: any[]
  onFolderClick: (folderId: string) => void
  onDelete: (fileId: string) => void
}

export function FileGrid({ files, folders, onFolderClick, onDelete }: FileGridProps) {
  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return '0 Bytes'
    const k = 1024
    const sizes = ['Bytes', 'KB', 'MB', 'GB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
  }

  return (
    <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
      {/* Folders */}
      {folders.map((folder) => (
        <div
          key={folder.id}
          className="group relative flex flex-col items-center p-4 rounded-lg hover:bg-gray-50 cursor-pointer"
          onClick={() => onFolderClick(folder.id)}
        >
          <Icons.folder className="h-12 w-12 text-blue-500 mb-2" />
          <span className="text-sm font-medium text-center truncate w-full">
            {folder.name}
          </span>
          
          <DropdownMenu>
            <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>
              <Button
                variant="ghost"
                size="sm"
                className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity"
              >
                <Icons.moreVertical className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem>Rename</DropdownMenuItem>
              <DropdownMenuItem>Move</DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem className="text-red-600">
                Delete
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      ))}

      {/* Files */}
      {files.map((file) => (
        <div
          key={file.id}
          className="group relative flex flex-col items-center p-4 rounded-lg hover:bg-gray-50"
        >
          <FileIcon type={file.type} className="h-12 w-12 mb-2" />
          <span className="text-sm font-medium text-center truncate w-full">
            {file.name}
          </span>
          <span className="text-xs text-gray-500">
            {formatFileSize(file.size)}
          </span>
          
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                variant="ghost"
                size="sm"
                className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity"
              >
                <Icons.moreVertical className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem>Download</DropdownMenuItem>
              <DropdownMenuItem>Share</DropdownMenuItem>
              <DropdownMenuItem>Rename</DropdownMenuItem>
              <DropdownMenuItem>Move</DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem 
                className="text-red-600"
                onClick={() => onDelete(file.id)}
              >
                Delete
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      ))}
    </div>
  )
}

// src/components/storage/file-list.tsx
'use client'

import { formatDistanceToNow } from 'date-fns'
import { FileIcon } from './file-icon'
import { Button } from '@/components/ui/button'
import { Icons } from '@/components/ui/icons'
import { Checkbox } from '@/components/ui/checkbox'
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'

interface FileListProps {
  files: any[]
  folders: any[]
  onFolderClick: (folderId: string) => void
  onDelete: (fileId: string) => void
}

export function FileList({ files, folders, onFolderClick, onDelete }: FileListProps) {
  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return '0 Bytes'
    const k = 1024
    const sizes = ['Bytes', 'KB', 'MB', 'GB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
  }

  const items = [
    ...folders.map(f => ({ ...f, isFolder: true })),
    ...files.map(f => ({ ...f, isFolder: false })),
  ]

  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead className="w-12">
            <Checkbox />
          </TableHead>
          <TableHead>Name</TableHead>
          <TableHead>Size</TableHead>
          <TableHead>Modified</TableHead>
          <TableHead className="w-12"></TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {items.map((item) => (
          <TableRow
            key={item.id}
            className="cursor-pointer hover:bg-gray-50"
            onClick={() => item.isFolder && onFolderClick(item.id)}
          >
            <TableCell onClick={(e) => e.stopPropagation()}>
              <Checkbox />
            </TableCell>
            <TableCell>
              <div className="flex items-center space-x-3">
                {item.isFolder ? (
                  <Icons.folder className="h-5 w-5 text-blue-500" />
                ) : (
                  <FileIcon type={item.type} className="h-5 w-5" />
                )}
                <span className="font-medium">{item.name}</span>
              </div>
            </TableCell>
            <TableCell>
              {item.isFolder ? '' : formatFileSize(item.size)}
            </TableCell>
            <TableCell>
              {formatDistanceToNow(new Date(item.created_at), { addSuffix: true })}
            </TableCell>
            <TableCell onClick={(e) => e.stopPropagation()}>
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="ghost" size="sm">
                    <Icons.moreVertical className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  {!item.isFolder && (
                    <>
                      <DropdownMenuItem>Download</DropdownMenuItem>
                      <DropdownMenuItem>Share</DropdownMenuItem>
                    </>
                  )}
                  <DropdownMenuItem>Rename</DropdownMenuItem>
                  <DropdownMenuItem>Move</DropdownMenuItem>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem
                    className="text-red-600"
                    onClick={() => !item.isFolder && onDelete(item.id)}
                  >
                    Delete
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  )
}

// src/components/storage/file-icon.tsx
'use client'

import { Icons } from '@/components/ui/icons'

interface FileIconProps {
  type: string
  className?: string
}

export function FileIcon({ type, className }: FileIconProps) {
  const getIcon = () => {
    if (type.startsWith('image/')) {
      return <Icons.image className={className} />
    }
    if (type.startsWith('video/')) {
      return <Icons.video className={className} />
    }
    if (type.startsWith('audio/')) {
      return <Icons.music className={className} />
    }
    if (type === 'application/pdf') {
      return <Icons.fileText className={className} />
    }
    if (
      type === 'application/zip' ||
      type === 'application/x-zip-compressed' ||
      type === 'application/x-rar-compressed'
    ) {
      return <Icons.archive className={className} />
    }
    if (
      type.includes('spreadsheet') ||
      type.includes('excel') ||
      type === 'text/csv'
    ) {
      return <Icons.sheet className={className} />
    }
    if (
      type.includes('document') ||
      type.includes('word') ||
      type === 'text/plain'
    ) {
      return <Icons.fileText className={className} />
    }
    if (type.includes('presentation') || type.includes('powerpoint')) {
      return <Icons.presentation className={className} />
    }
    
    return <Icons.file className={className} />
  }

  return getIcon()
}

// src/components/storage/folder-breadcrumb.tsx
'use client'

import { useEffect, useState } from 'react'
import { ChevronRight } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { createClient } from '@/lib/supabase/client'

interface FolderBreadcrumbProps {
  currentFolder?: string
  onNavigate: (folderId: string | undefined) => void
}

interface BreadcrumbItem {
  id: string
  name: string
}

export function FolderBreadcrumb({ currentFolder, onNavigate }: FolderBreadcrumbProps) {
  const [breadcrumbs, setBreadcrumbs] = useState<BreadcrumbItem[]>([])
  const supabase = createClient()

  useEffect(() => {
    if (!currentFolder) {
      setBreadcrumbs([])
      return
    }

    const fetchBreadcrumbs = async () => {
      const items: BreadcrumbItem[] = []
      let folderId: string | null = currentFolder

      while (folderId) {
        const { data } = await supabase
          .from('folders')
          .select('id, name, parent_id')
          .eq('id', folderId)
          .single()

        if (data) {
          items.unshift({ id: data.id, name: data.name })
          folderId = data.parent_id
        } else {
          break
        }
      }

      setBreadcrumbs(items)
    }

    fetchBreadcrumbs()
  }, [currentFolder, supabase])

  return (
    <div className="flex items-center space-x-1 text-sm">
      <Button
        variant="ghost"
        size="sm"
        onClick={() => onNavigate(undefined)}
        className="px-2"
      >
        Home
      </Button>
      
      {breadcrumbs.map((item, index) => (
        <div key={item.id} className="flex items-center">
          <ChevronRight className="h-4 w-4 text-gray-400" />
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onNavigate(item.id)}
            className="px-2"
          >
            {item.name}
          </Button>
        </div>
      ))}
    </div>
  )
}

// src/components/ui/checkbox.tsx
'use client'

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"
import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }





// src/lib/realtime/service.ts
import { createClient } from '@/lib/supabase/server'
import { RealtimeChannel, RealtimePostgresChangesPayload } from '@supabase/supabase-js'

export interface RealtimeEvent {
  type: 'INSERT' | 'UPDATE' | 'DELETE'
  table: string
  record: any
  old_record?: any
  timestamp: string
}

export interface BroadcastMessage {
  type: string
  payload: any
  user_id: string
  timestamp: string
}

export class RealtimeService {
  // Subscribe to database changes
  static subscribeToTable(
    table: string,
    callback: (event: RealtimeEvent) => void,
    options?: {
      event?: 'INSERT' | 'UPDATE' | 'DELETE' | '*'
      filter?: string
      schema?: string
    }
  ): RealtimeChannel {
    const supabase = createClient()
    
    const channel = supabase
      .channel(`db-${table}`)
      .on(
        'postgres_changes',
        {
          event: options?.event || '*',
          schema: options?.schema || 'public',
          table,
          filter: options?.filter,
        },
        (payload: RealtimePostgresChangesPayload<any>) => {
          const event: RealtimeEvent = {
            type: payload.eventType as any,
            table: payload.table,
            record: payload.new || payload.old,
            old_record: payload.old,
            timestamp: new Date().toISOString(),
          }
          callback(event)
        }
      )
      .subscribe()

    return channel
  }

  // Subscribe to presence (who's online)
  static subscribeToPresence(
    channelName: string,
    userId: string,
    userMetadata: any,
    callbacks: {
      onSync?: () => void
      onJoin?: (userId: string, metadata: any) => void
      onLeave?: (userId: string) => void
    }
  ): RealtimeChannel {
    const supabase = createClient()
    
    const channel = supabase.channel(channelName)

    // Track user presence
    channel.on('presence', { event: 'sync' }, () => {
      const state = channel.presenceState()
      callbacks.onSync?.()
    })

    channel.on('presence', { event: 'join' }, ({ key, newPresences }) => {
      callbacks.onJoin?.(key, newPresences[0])
    })

    channel.on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
      callbacks.onLeave?.(key)
    })

    channel.subscribe(async (status) => {
      if (status === 'SUBSCRIBED') {
        await channel.track({
          user_id: userId,
          online_at: new Date().toISOString(),
          ...userMetadata,
        })
      }
    })

    return channel
  }

  // Subscribe to broadcast messages
  static subscribeToBroadcast(
    channelName: string,
    callback: (message: BroadcastMessage) => void
  ): RealtimeChannel {
    const supabase = createClient()
    
    const channel = supabase
      .channel(channelName)
      .on('broadcast', { event: '*' }, (payload) => {
        callback(payload.payload as BroadcastMessage)
      })
      .subscribe()

    return channel
  }

  // Send broadcast message
  static async broadcast(
    channelName: string,
    message: Omit<BroadcastMessage, 'timestamp'>
  ) {
    const supabase = createClient()
    
    const channel = supabase.channel(channelName)
    
    await channel.send({
      type: 'broadcast',
      event: message.type,
      payload: {
        ...message,
        timestamp: new Date().toISOString(),
      },
    })
  }

  // Unsubscribe from channel
  static async unsubscribe(channel: RealtimeChannel) {
    const supabase = createClient()
    await supabase.removeChannel(channel)
  }

  // Get presence state
  static getPresenceState(channel: RealtimeChannel) {
    return channel.presenceState()
  }
}

// src/lib/realtime/notifications.ts
import { RealtimeService } from './service'
import { NotificationStore } from '@/stores/notification-store'

export interface RealtimeNotification {
  id: string
  type: 'info' | 'success' | 'warning' | 'error'
  title: string
  message: string
  user_id: string
  organization_id?: string
  read: boolean
  created_at: string
}

export class RealtimeNotificationService {
  private static channels: Map<string, any> = new Map()

  // Subscribe to user notifications
  static subscribeToUserNotifications(userId: string) {
    const channelKey = `user-notifications-${userId}`
    
    // Avoid duplicate subscriptions
    if (this.channels.has(channelKey)) {
      return
    }

    const channel = RealtimeService.subscribeToTable(
      'notifications',
      (event) => {
        if (event.type === 'INSERT') {
          // Add to notification store
          NotificationStore.getState().addNotification({
            title: event.record.title,
            message: event.record.message,
            type: event.record.type,
            read: false,
          })
        }
      },
      {
        event: 'INSERT',
        filter: `user_id=eq.${userId}`,
      }
    )

    this.channels.set(channelKey, channel)
  }

  // Subscribe to organization notifications
  static subscribeToOrganizationNotifications(organizationId: string) {
    const channelKey = `org-notifications-${organizationId}`
    
    if (this.channels.has(channelKey)) {
      return
    }

    const channel = RealtimeService.subscribeToTable(
      'notifications',
      (event) => {
        if (event.type === 'INSERT') {
          NotificationStore.getState().addNotification({
            title: event.record.title,
            message: event.record.message,
            type: event.record.type,
            read: false,
          })
        }
      },
      {
        event: 'INSERT',
        filter: `organization_id=eq.${organizationId}`,
      }
    )

    this.channels.set(channelKey, channel)
  }

  // Unsubscribe from all notifications
  static async unsubscribeAll() {
    for (const [key, channel] of this.channels) {
      await RealtimeService.unsubscribe(channel)
    }
    this.channels.clear()
  }
}

// src/lib/realtime/collaboration.ts
import { RealtimeService, BroadcastMessage } from './service'

export interface CollaborationEvent {
  type: 'cursor' | 'selection' | 'edit' | 'comment'
  userId: string
  userName?: string
  data: any
}

export class CollaborationService {
  private static channels: Map<string, any> = new Map()
  private static callbacks: Map<string, (event: CollaborationEvent) => void> = new Map()

  // Join collaboration session
  static joinSession(
    documentId: string,
    userId: string,
    userName: string,
    callback: (event: CollaborationEvent) => void
  ) {
    const channelKey = `collab-${documentId}`
    
    // Store callback
    this.callbacks.set(channelKey, callback)

    // Subscribe to broadcast
    const channel = RealtimeService.subscribeToBroadcast(
      channelKey,
      (message: BroadcastMessage) => {
        // Don't process own messages
        if (message.user_id === userId) return
        
        const event: CollaborationEvent = {
          type: message.type as any,
          userId: message.user_id,
          userName: message.payload.userName,
          data: message.payload.data,
        }
        
        callback(event)
      }
    )

    // Subscribe to presence
    RealtimeService.subscribeToPresence(
      channelKey,
      userId,
      { userName },
      {
        onJoin: (joinedUserId, metadata) => {
          if (joinedUserId !== userId) {
            callback({
              type: 'cursor',
              userId: joinedUserId,
              userName: metadata.userName,
              data: { joined: true },
            })
          }
        },
        onLeave: (leftUserId) => {
          callback({
            type: 'cursor',
            userId: leftUserId,
            data: { left: true },
          })
        },
      }
    )

    this.channels.set(channelKey, channel)
  }

  // Send collaboration event
  static async sendEvent(
    documentId: string,
    event: Omit<CollaborationEvent, 'userId'>
  ) {
    const channelKey = `collab-${documentId}`
    
    await RealtimeService.broadcast(channelKey, {
      type: event.type,
      user_id: event.userId!,
      payload: {
        userName: event.userName,
        data: event.data,
      },
    })
  }

  // Get active collaborators
  static getActiveCollaborators(documentId: string) {
    const channelKey = `collab-${documentId}`
    const channel = this.channels.get(channelKey)
    
    if (!channel) return []
    
    const presenceState = RealtimeService.getPresenceState(channel)
    return Object.entries(presenceState).map(([userId, presence]) => ({
      userId,
      ...presence[0],
    }))
  }

  // Leave session
  static async leaveSession(documentId: string) {
    const channelKey = `collab-${documentId}`
    const channel = this.channels.get(channelKey)
    
    if (channel) {
      await RealtimeService.unsubscribe(channel)
      this.channels.delete(channelKey)
      this.callbacks.delete(channelKey)
    }
  }
}

// src/lib/realtime/activity.ts
import { RealtimeService } from './service'

export interface ActivityEvent {
  id: string
  type: string
  action: string
  resource_type: string
  resource_id: string
  resource_name?: string
  user_id: string
  user_name?: string
  organization_id?: string
  metadata?: any
  created_at: string
}

export class ActivityService {
  // Log activity
  static async logActivity(activity: Omit<ActivityEvent, 'id' | 'created_at'>) {
    const supabase = createClient()
    
    await supabase.from('activity_logs').insert({
      ...activity,
      created_at: new Date().toISOString(),
    })
  }

  // Subscribe to organization activity
  static subscribeToOrganizationActivity(
    organizationId: string,
    callback: (activity: ActivityEvent) => void
  ) {
    return RealtimeService.subscribeToTable(
      'activity_logs',
      (event) => {
        if (event.type === 'INSERT') {
          callback(event.record as ActivityEvent)
        }
      },
      {
        event: 'INSERT',
        filter: `organization_id=eq.${organizationId}`,
      }
    )
  }

  // Get recent activity
  static async getRecentActivity(options: {
    organizationId?: string
    userId?: string
    limit?: number
  }) {
    const supabase = createClient()
    
    let query = supabase
      .from('activity_logs')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(options.limit || 50)

    if (options.organizationId) {
      query = query.eq('organization_id', options.organizationId)
    }

    if (options.userId) {
      query = query.eq('user_id', options.userId)
    }

    const { data, error } = await query

    if (error) {
      throw new Error(error.message)
    }

    return data
  }
}














// src/app/(admin)/admin/users/page.tsx
'use client'

import { useState } from 'react'
import { useAdminUsers } from '@/hooks/use-admin'
import { DataTable } from '@/components/ui/data-table'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar'
import { Icons } from '@/components/ui/icons'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { format } from 'date-fns'
import { ColumnDef } from '@tanstack/react-table'

interface User {
  id: string
  email: string
  name?: string
  avatar_url?: string
  role: 'USER' | 'ADMIN' | 'SUPER_ADMIN'
  created_at: string
  last_sign_in?: string
  subscription?: {
    status: string
    plan: string
  }
}

export default function AdminUsersPage() {
  const { users, loading, stats, updateUserRole, deleteUser, impersonateUser } = useAdminUsers()
  const [selectedUser, setSelectedUser] = useState<User | null>(null)
  const [showEditDialog, setShowEditDialog] = useState(false)
  const [showDeleteDialog, setShowDeleteDialog] = useState(false)

  const columns: ColumnDef<User>[] = [
    {
      accessorKey: 'user',
      header: 'User',
      cell: ({ row }) => {
        const user = row.original
        return (
          <div className="flex items-center space-x-3">
            <Avatar className="h-8 w-8">
              <AvatarImage src={user.avatar_url} />
              <AvatarFallback>
                {user.name?.charAt(0) || user.email.charAt(0).toUpperCase()}
              </AvatarFallback>
            </Avatar>
            <div>
              <p className="font-medium">{user.name || 'No name'}</p>
              <p className="text-sm text-gray-500">{user.email}</p>
            </div>
          </div>
        )
      },
    },
    {
      accessorKey: 'role',
      header: 'Role',
      cell: ({ row }) => {
        const role = row.getValue('role') as string
        return (
          <Badge variant={role === 'SUPER_ADMIN' ? 'default' : role === 'ADMIN' ? 'secondary' : 'outline'}>
            {role.replace('_', ' ')}
          </Badge>
        )
      },
    },
    {
      accessorKey: 'subscription',
      header: 'Subscription',
      cell: ({ row }) => {
        const sub = row.original.subscription
        if (!sub) return <span className="text-gray-500">Free</span>
        
        return (
          <div className="flex items-center space-x-2">
            <Badge variant={sub.status === 'active' ? 'default' : 'secondary'}>
              {sub.plan}
            </Badge>
            <span className="text-xs text-gray-500">{sub.status}</span>
          </div>
        )
      },
    },
    {
      accessorKey: 'created_at',
      header: 'Joined',
      cell: ({ row }) => {
        return (
          <span className="text-sm text-gray-500">
            {format(new Date(row.getValue('created_at')), 'MMM d, yyyy')}
          </span>
        )
      },
    },
    {
      accessorKey: 'last_sign_in',
      header: 'Last Active',
      cell: ({ row }) => {
        const lastSignIn = row.getValue('last_sign_in') as string | undefined
        if (!lastSignIn) return <span className="text-gray-500">Never</span>
        
        return (
          <span className="text-sm text-gray-500">
            {format(new Date(lastSignIn), 'MMM d, yyyy')}
          </span>
        )
      },
    },
    {
      id: 'actions',
      cell: ({ row }) => {
        const user = row.original
        
        return (
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" className="h-8 w-8 p-0">
                <Icons.moreVertical className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuLabel>Actions</DropdownMenuLabel>
              <DropdownMenuItem onClick={() => {
                setSelectedUser(user)
                setShowEditDialog(true)
              }}>
                <Icons.edit className="mr-2 h-4 w-4" />
                Edit Role
              </DropdownMenuItem>
              <DropdownMenuItem onClick={() => impersonateUser(user.id)}>
                <Icons.user className="mr-2 h-4 w-4" />
                Impersonate
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem 
                className="text-red-600"
                onClick={() => {
                  setSelectedUser(user)
                  setShowDeleteDialog(true)
                }}
              >
                <Icons.delete className="mr-2 h-4 w-4" />
                Delete User
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        )
      },
    },
  ]

  const handleUpdateRole = async (newRole: string) => {
    if (!selectedUser) return
    
    try {
      await updateUserRole(selectedUser.id, newRole as any)
      setShowEditDialog(false)
      setSelectedUser(null)
    } catch (error) {
      console.error('Failed to update role:', error)
    }
  }

  const handleDeleteUser = async () => {
    if (!selectedUser) return
    
    try {
      await deleteUser(selectedUser.id)
      setShowDeleteDialog(false)
      setSelectedUser(null)
    } catch (error) {
      console.error('Failed to delete user:', error)
    }
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Icons.spinner className="h-8 w-8 animate-spin text-gray-400" />
      </div>
    )
  }

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold">Users</h1>
        <p className="text-gray-600 mt-2">
          Manage all users in your application
        </p>
      </div>

      {/* Stats */}
      <div className="grid gap-4 md:grid-cols-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Total Users</CardTitle>
            <Icons.user className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.totalUsers}</div>
            <p className="text-xs text-muted-foreground">
              +{stats.newUsersThisMonth} this month
            </p>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Active Users</CardTitle>
            <Icons.userCheck className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.activeUsers}</div>
            <p className="text-xs text-muted-foreground">
              Last 30 days
            </p>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Paid Users</CardTitle>
            <Icons.creditCard className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.paidUsers}</div>
            <p className="text-xs text-muted-foreground">
              {Math.round((stats.paidUsers / stats.totalUsers) * 100)}% conversion
            </p>
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Admins</CardTitle>
            <Icons.shield className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.adminUsers}</div>
            <p className="text-xs text-muted-foreground">
              With elevated permissions
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Users Table */}
      <Card>
        <CardHeader>
          <CardTitle>All Users</CardTitle>
          <CardDescription>
            A list of all users including their role, subscription status, and activity.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <DataTable
            columns={columns}
            data={users}
            searchColumn="email"
            searchPlaceholder="Search by email..."
          />
        </CardContent>
      </Card>

      {/* Edit Role Dialog */}
      <Dialog open={showEditDialog} onOpenChange={setShowEditDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Edit User Role</DialogTitle>
            <DialogDescription>
              Change the role for {selectedUser?.email}
            </DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <Label htmlFor="role">Role</Label>
              <Select defaultValue={selectedUser?.role} onValueChange={handleUpdateRole}>
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="USER">User</SelectItem>
                  <SelectItem value="ADMIN">Admin</SelectItem>
                  <SelectItem value="SUPER_ADMIN">Super Admin</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </DialogContent>
      </Dialog>

      {/* Delete Confirmation Dialog */}
      <Dialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Delete User</DialogTitle>
            <DialogDescription>
              Are you sure you want to delete {selectedUser?.email}? This action cannot be undone.
            </DialogDescription>
          </DialogHeader>
          
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowDeleteDialog(false)}>
              Cancel
            </Button>
            <Button variant="destructive" onClick={handleDeleteUser}>
              Delete User
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  )
}

// src/hooks/use-admin.ts
'use client'

import { useEffect, useState, useCallback } from 'react'
import { useRouter } from 'next/navigation'
import { createClient } from '@/lib/supabase/client'

interface AdminStats {
  totalUsers: number
  activeUsers: number
  paidUsers: number
  adminUsers: number
  newUsersThisMonth: number
}

export function useAdminUsers() {
  const [users, setUsers] = useState<any[]>([])
  const [stats, setStats] = useState<AdminStats>({
    totalUsers: 0,
    activeUsers: 0,
    paidUsers: 0,
    adminUsers: 0,
    newUsersThisMonth: 0,
  })
  const [loading, setLoading] = useState(true)
  const router = useRouter()

  useEffect(() => {
    fetchUsersAndStats()
  }, [])

  const fetchUsersAndStats = async () => {
    setLoading(true)
    try {
      const response = await fetch('/api/admin/users')
      const data = await response.json()

      if (response.ok) {
        setUsers(data.users)
        setStats(data.stats)
      }
    } catch (error) {
      console.error('Failed to fetch users:', error)
    } finally {
      setLoading(false)
    }
  }

  const updateUserRole = useCallback(async (userId: string, role: string) => {
    const response = await fetch(`/api/admin/users/${userId}/role`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ role }),
    })

    if (!response.ok) {
      throw new Error('Failed to update user role')
    }

    await fetchUsersAndStats()
  }, [])

  const deleteUser = useCallback(async (userId: string) => {
    const response = await fetch(`/api/admin/users/${userId}`, {
      method: 'DELETE',
    })

    if (!response.ok) {
      throw new Error('Failed to delete user')
    }

    await fetchUsersAndStats()
  }, [])

  const impersonateUser = useCallback(async (userId: string) => {
    const response = await fetch(`/api/admin/users/${userId}/impersonate`, {
      method: 'POST',
    })

    if (!response.ok) {
      throw new Error('Failed to impersonate user')
    }

    router.push('/dashboard')
  }, [router])

  return {
    users,
    stats,
    loading,
    updateUserRole,
    deleteUser,
    impersonateUser,
    refresh: fetchUsersAndStats,
  }
}











// src/app/(dashboard)/settings/page.tsx
'use client'

import { useState } from 'react'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { ProfileSettings } from '@/components/settings/profile-settings'
import { AccountSettings } from '@/components/settings/account-settings'
import { NotificationSettings } from '@/components/settings/notification-settings'
import { SecuritySettings } from '@/components/settings/security-settings'
import { ApiKeys } from '@/components/settings/api-keys'
import { AppearanceSettings } from '@/components/settings/appearance-settings'

export default function SettingsPage() {
  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold">Settings</h1>
        <p className="text-gray-600 mt-2">
          Manage your account settings and preferences
        </p>
      </div>

      <Tabs defaultValue="profile" className="w-full">
        <TabsList className="grid w-full grid-cols-6">
          <TabsTrigger value="profile">Profile</TabsTrigger>
          <TabsTrigger value="account">Account</TabsTrigger>
          <TabsTrigger value="security">Security</TabsTrigger>
          <TabsTrigger value="notifications">Notifications</TabsTrigger>
          <TabsTrigger value="api">API Keys</TabsTrigger>
          <TabsTrigger value="appearance">Appearance</TabsTrigger>
        </TabsList>

        <TabsContent value="profile" className="mt-6">
          <ProfileSettings />
        </TabsContent>

        <TabsContent value="account" className="mt-6">
          <AccountSettings />
        </TabsContent>

        <TabsContent value="security" className="mt-6">
          <SecuritySettings />
        </TabsContent>

        <TabsContent value="notifications" className="mt-6">
          <NotificationSettings />
        </TabsContent>

        <TabsContent value="api" className="mt-6">
          <ApiKeys />
        </TabsContent>

        <TabsContent value="appearance" className="mt-6">
          <AppearanceSettings />
        </TabsContent>
      </Tabs>
    </div>
  )
}

// src/components/settings/profile-settings.tsx
'use client'

import { useState } from 'react'
import { useUser } from '@/hooks/use-user'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Textarea } from '@/components/ui/textarea'
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { Icons } from '@/components/ui/icons'

export function ProfileSettings() {
  const { user, profile, updateProfile, updateUser } = useUser()
  const [loading, setLoading] = useState(false)
  const [success, setSuccess] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [formData, setFormData] = useState({
    name: user?.name || '',
    bio: profile?.bio || '',
    website: profile?.website || '',
    location: profile?.location || '',
  })

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setLoading(true)
    setSuccess(false)
    setError(null)

    try {
      // Update user name
      if (formData.name !== user?.name) {
        const { error } = await updateUser({ name: formData.name })
        if (error) throw new Error(error)
      }

      // Update profile
      const { error } = await updateProfile({
        bio: formData.bio,
        website: formData.website,
        location: formData.location,
      })

      if (error) throw new Error(error)

      setSuccess(true)
    } catch (err: any) {
      setError(err.message)
    } finally {
      setLoading(false)
    }
  }

  const handleAvatarUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    // TODO: Implement avatar upload
    console.log('Avatar upload:', file)
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Profile Information</CardTitle>
        <CardDescription>
          Update your profile information that will be visible to others
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-6">
          {success && (
            <Alert>
              <Icons.check className="h-4 w-4" />
              <AlertDescription>Profile updated successfully</AlertDescription>
            </Alert>
          )}

          {error && (
            <Alert variant="destructive">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          <div className="flex items-center space-x-4">
            <Avatar className="h-20 w-20">
              <AvatarImage src={user?.avatar_url} />
              <AvatarFallback>
                {user?.name?.charAt(0) || user?.email?.charAt(0).toUpperCase()}
              </AvatarFallback>
            </Avatar>
            <div>
              <Label htmlFor="avatar" className="cursor-pointer">
                <Button variant="outline" size="sm" asChild>
                  <span>Change Avatar</span>
                </Button>
              </Label>
              <input
                id="avatar"
                type="file"
                accept="image/*"
                className="hidden"
                onChange={handleAvatarUpload}
              />
              <p className="text-xs text-gray-500 mt-1">
                JPG, GIF or PNG. Max size 2MB.
              </p>
            </div>
          </div>

          <div className="grid gap-4">
            <div>
              <Label htmlFor="name">Name</Label>
              <Input
                id="name"
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                placeholder="Your name"
              />
            </div>

            <div>
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                value={user?.email || ''}
                disabled
                className="bg-gray-50"
              />
              <p className="text-xs text-gray-500 mt-1">
                Email cannot be changed
              </p>
            </div>

            <div>
              <Label htmlFor="bio">Bio</Label>
              <Textarea
                id="bio"
                value={formData.bio}
                onChange={(e) => setFormData({ ...formData, bio: e.target.value })}
                placeholder="Tell us about yourself"
                rows={3}
              />
            </div>

            <div>
              <Label htmlFor="website">Website</Label>
              <Input
                id="website"
                type="url"
                value={formData.website}
                onChange={(e) => setFormData({ ...formData, website: e.target.value })}
                placeholder="https://example.com"
              />
            </div>

            <div>
              <Label htmlFor="location">Location</Label>
              <Input
                id="location"
                value={formData.location}
                onChange={(e) => setFormData({ ...formData, location: e.target.value })}
                placeholder="San Francisco, CA"
              />
            </div>
          </div>

          <Button type="submit" disabled={loading}>
            {loading ? 'Saving...' : 'Save Changes'}
          </Button>
        </form>
      </CardContent>
    </Card>
  )
}

// src/components/settings/security-settings.tsx
'use client'

import { TwoFactorSetup } from '@/components/auth/two-factor-setup'
import { SessionList } from '@/components/auth/session-list'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { Icons } from '@/components/ui/icons'
import { useState } from 'react'
import { useAuth } from '@/hooks/use-auth'

export function SecuritySettings() {
  const { updatePassword } = useAuth()
  const [passwordForm, setPasswordForm] = useState({
    currentPassword: '',
    newPassword: '',
    confirmPassword: '',
  })
  const [passwordLoading, setPasswordLoading] = useState(false)
  const [passwordError, setPasswordError] = useState<string | null>(null)
  const [passwordSuccess, setPasswordSuccess] = useState(false)

  const handlePasswordChange = async (e: React.FormEvent) => {
    e.preventDefault()
    setPasswordLoading(true)
    setPasswordError(null)
    setPasswordSuccess(false)

    if (passwordForm.newPassword !== passwordForm.confirmPassword) {
      setPasswordError('Passwords do not match')
      setPasswordLoading(false)
      return
    }

    if (passwordForm.newPassword.length < 8) {
      setPasswordError('Password must be at least 8 characters')
      setPasswordLoading(false)
      return
    }

    const { error } = await updatePassword(passwordForm.newPassword)

    if (error) {
      setPasswordError(error)
    } else {
      setPasswordSuccess(true)
      setPasswordForm({
        currentPassword: '',
        newPassword: '',
        confirmPassword: '',
      })
    }

    setPasswordLoading(false)
  }

  return (
    <div className="space-y-6">
      {/* Change Password */}
      <Card>
        <CardHeader>
          <CardTitle>Change Password</CardTitle>
          <CardDescription>
            Update your password to keep your account secure
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handlePasswordChange} className="space-y-4">
            {passwordSuccess && (
              <Alert>
                <Icons.check className="h-4 w-4" />
                <AlertDescription>Password updated successfully</AlertDescription>
              </Alert>
            )}

            {passwordError && (
              <Alert variant="destructive">
                <AlertDescription>{passwordError}</AlertDescription>
              </Alert>
            )}

            <div>
              <Label htmlFor="current-password">Current Password</Label>
              <Input
                id="current-password"
                type="password"
                value={passwordForm.currentPassword}
                onChange={(e) => setPasswordForm({ ...passwordForm, currentPassword: e.target.value })}
                required
              />
            </div>

            <div>
              <Label htmlFor="new-password">New Password</Label>
              <Input
                id="new-password"
                type="password"
                value={passwordForm.newPassword}
                onChange={(e) => setPasswordForm({ ...passwordForm, newPassword: e.target.value })}
                required
              />
              <p className="text-xs text-gray-500 mt-1">
                Must be at least 8 characters
              </p>
            </div>

            <div>
              <Label htmlFor="confirm-password">Confirm New Password</Label>
              <Input
                id="confirm-password"
                type="password"
                value={passwordForm.confirmPassword}
                onChange={(e) => setPasswordForm({ ...passwordForm, confirmPassword: e.target.value })}
                required
              />
            </div>

            <Button type="submit" disabled={passwordLoading}>
              {passwordLoading ? 'Updating...' : 'Update Password'}
            </Button>
          </form>
        </CardContent>
      </Card>

      {/* Two-Factor Authentication */}
      <TwoFactorSetup />

      {/* Active Sessions */}
      <SessionList />
    </div>
  )
}

// src/components/settings/api-keys.tsx
'use client'

import { useState, useEffect } from 'react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Badge } from '@/components/ui/badge'
import { Icons } from '@/components/ui/icons'
import { formatDistanceToNow } from 'date-fns'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table'
import { useApiKeys } from '@/hooks/use-api-keys'

export function ApiKeys() {
  const { apiKeys, loading, createApiKey, deleteApiKey } = useApiKeys()
  const [showCreateDialog, setShowCreateDialog] = useState(false)
  const [showKeyDialog, setShowKeyDialog] = useState(false)
  const [newKeyName, setNewKeyName] = useState('')
  const [newKeyValue, setNewKeyValue] = useState('')
  const [creating, setCreating] = useState(false)

  const handleCreateKey = async () => {
    if (!newKeyName.trim()) return

    setCreating(true)
    try {
      const { key } = await createApiKey(newKeyName)
      setNewKeyValue(key)
      setShowCreateDialog(false)
      setShowKeyDialog(true)
      setNewKeyName('')
    } catch (error) {
      console.error('Failed to create API key:', error)
    } finally {
      setCreating(false)
    }
  }

  const handleDeleteKey = async (keyId: string) => {
    if (!confirm('Are you sure you want to delete this API key?')) return

    try {
      await deleteApiKey(keyId)
    } catch (error) {
      console.error('Failed to delete API key:', error)
    }
  }

  const copyToClipboard = () => {
    navigator.clipboard.writeText(newKeyValue)
  }

  return (
    <>
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle>API Keys</CardTitle>
              <CardDescription>
                Manage your API keys for programmatic access
              </CardDescription>
            </div>
            <Button onClick={() => setShowCreateDialog(true)}>
              <Icons.add className="h-4 w-4 mr-2" />
              Create Key
            </Button>
          </div>
        </CardHeader>
        <CardContent>
          {loading ? (
            <div className="flex items-center justify-center py-8">
              <Icons.spinner className="h-6 w-6 animate-spin text-gray-400" />
            </div>
          ) : apiKeys.length === 0 ? (
            <p className="text-center text-sm text-gray-500 py-8">
              No API keys yet. Create one to get started.
            </p>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Name</TableHead>
                  <TableHead>Key</TableHead>
                  <TableHead>Last Used</TableHead>
                  <TableHead>Created</TableHead>
                  <TableHead className="w-12"></TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {apiKeys.map((apiKey) => (
                  <TableRow key={apiKey.id}>
                    <TableCell className="font-medium">{apiKey.name}</TableCell>
                    <TableCell>
                      <code className="rounded bg-gray-100 px-2 py-1 text-xs">
                        {apiKey.key.slice(0, 7)}...{apiKey.key.slice(-4)}
                      </code>
                    </TableCell>
                    <TableCell>
                      {apiKey.last_used_at ? (
                        formatDistanceToNow(new Date(apiKey.last_used_at), { addSuffix: true })
                      ) : (
                        <span className="text-gray-500">Never</span>
                      )}
                    </TableCell>
                    <TableCell>
                      {formatDistanceToNow(new Date(apiKey.created_at), { addSuffix: true })}
                    </TableCell>
                    <TableCell>
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => handleDeleteKey(apiKey.id)}
                      >
                        <Icons.delete className="h-4 w-4" />
                      </Button>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>

      {/* Create API Key Dialog */}
      <Dialog open={showCreateDialog} onOpenChange={setShowCreateDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Create API Key</DialogTitle>
            <DialogDescription>
              Give your API key a name to help you remember its purpose
            </DialogDescription>
          </DialogHeader>
          
          <div>
            <Label htmlFor="key-name">Key Name</Label>
            <Input
              id="key-name"
              value={newKeyName}
              onChange={(e) => setNewKeyName(e.target.value)}
              placeholder="Production API Key"
            />
          </div>

          <DialogFooter>
            <Button variant="outline" onClick={() => setShowCreateDialog(false)}>
              Cancel
            </Button>
            <Button onClick={handleCreateKey} disabled={creating || !newKeyName.trim()}>
              {creating ? 'Creating...' : 'Create Key'}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Show New API Key Dialog */}
      <Dialog open={showKeyDialog} onOpenChange={setShowKeyDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Your New API Key</DialogTitle>
            <DialogDescription>
              Make sure to copy your API key now. You won't be able to see it again!
            </DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4">
            <div className="rounded-lg bg-gray-100 p-4">
              <code className="text-sm break-all">{newKeyValue}</code>
            </div>
            
            <Button onClick={copyToClipboard} className="w-full">
              <Icons.copy className="h-4 w-4 mr-2" />
              Copy to Clipboard
            </Button>
          </div>

          <DialogFooter>
            <Button onClick={() => setShowKeyDialog(false)}>
              I've Saved My Key
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  )
}





// src/components/settings/account-settings.tsx
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { useAuth } from '@/hooks/use-auth'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { Icons } from '@/components/ui/icons'
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from '@/components/ui/alert-dialog'

export function AccountSettings() {
  const router = useRouter()
  const { user } = useAuth()
  const [deleting, setDeleting] = useState(false)

  const handleDeleteAccount = async () => {
    setDeleting(true)
    
    try {
      const response = await fetch('/api/users/delete-account', {
        method: 'DELETE',
      })

      if (!response.ok) {
        throw new Error('Failed to delete account')
      }

      // Sign out and redirect
      router.push('/goodbye')
    } catch (error) {
      console.error('Failed to delete account:', error)
      setDeleting(false)
    }
  }

  const handleExportData = async () => {
    try {
      const response = await fetch('/api/users/export-data')
      const blob = await response.blob()
      
      // Download the file
      const url = window.URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `user-data-${user?.id}.json`
      document.body.appendChild(a)
      a.click()
      window.URL.revokeObjectURL(url)
      document.body.removeChild(a)
    } catch (error) {
      console.error('Failed to export data:', error)
    }
  }

  return (
    <div className="space-y-6">
      {/* Export Data */}
      <Card>
        <CardHeader>
          <CardTitle>Export Your Data</CardTitle>
          <CardDescription>
            Download all your data in a machine-readable format
          </CardDescription>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-gray-600 mb-4">
            You can export your data at any time. This includes your profile information,
            files, and activity history.
          </p>
          <Button onClick={handleExportData} variant="outline">
            <Icons.download className="h-4 w-4 mr-2" />
            Export Data
          </Button>
        </CardContent>
      </Card>

      {/* Delete Account */}
      <Card className="border-red-200">
        <CardHeader>
          <CardTitle className="text-red-600">Delete Account</CardTitle>
          <CardDescription>
            Permanently delete your account and all associated data
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Alert variant="destructive" className="mb-4">
            <Icons.alertCircle className="h-4 w-4" />
            <AlertDescription>
              This action is irreversible. All your data will be permanently deleted.
            </AlertDescription>
          </Alert>

          <AlertDialog>
            <AlertDialogTrigger asChild>
              <Button variant="destructive" disabled={deleting}>
                Delete My Account
              </Button>
            </AlertDialogTrigger>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
                <AlertDialogDescription>
                  This action cannot be undone. This will permanently delete your
                  account and remove all your data from our servers.
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction
                  onClick={handleDeleteAccount}
                  className="bg-red-600 hover:bg-red-700"
                >
                  {deleting ? 'Deleting...' : 'Yes, delete my account'}
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>
        </CardContent>
      </Card>
    </div>
  )
}

// src/components/settings/notification-settings.tsx
'use client'

import { useState, useEffect } from 'react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Label } from '@/components/ui/label'
import { Switch } from '@/components/ui/switch'
import { Button } from '@/components/ui/button'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { Icons } from '@/components/ui/icons'

interface NotificationPreferences {
  email_marketing: boolean
  email_updates: boolean
  email_security: boolean
  push_enabled: boolean
  push_comments: boolean
  push_mentions: boolean
  push_updates: boolean
}

export function NotificationSettings() {
  const [preferences, setPreferences] = useState<NotificationPreferences>({
    email_marketing: false,
    email_updates: true,
    email_security: true,
    push_enabled: false,
    push_comments: true,
    push_mentions: true,
    push_updates: false,
  })
  const [loading, setLoading] = useState(false)
  const [success, setSuccess] = useState(false)

  useEffect(() => {
    fetchPreferences()
  }, [])

  const fetchPreferences = async () => {
    try {
      const response = await fetch('/api/users/notification-preferences')
      const data = await response.json()
      if (response.ok) {
        setPreferences(data)
      }
    } catch (error) {
      console.error('Failed to fetch preferences:', error)
    }
  }

  const handleSave = async () => {
    setLoading(true)
    setSuccess(false)

    try {
      const response = await fetch('/api/users/notification-preferences', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(preferences),
      })

      if (response.ok) {
        setSuccess(true)
      }
    } catch (error) {
      console.error('Failed to save preferences:', error)
    } finally {
      setLoading(false)
    }
  }

  const updatePreference = (key: keyof NotificationPreferences, value: boolean) => {
    setPreferences({ ...preferences, [key]: value })
  }

  return (
    <div className="space-y-6">
      {success && (
        <Alert>
          <Icons.check className="h-4 w-4" />
          <AlertDescription>Notification preferences updated successfully</AlertDescription>
        </Alert>
      )}

      {/* Email Notifications */}
      <Card>
        <CardHeader>
          <CardTitle>Email Notifications</CardTitle>
          <CardDescription>
            Choose which emails you want to receive
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center justify-between">
            <div className="space-y-0.5">
              <Label htmlFor="email-marketing">Marketing emails</Label>
              <p className="text-sm text-gray-500">
                News, product updates, and promotional content
              </p>
            </div>
            <Switch
              id="email-marketing"
              checked={preferences.email_marketing}
              onCheckedChange={(checked) => updatePreference('email_marketing', checked)}
            />
          </div>

          <div className="flex items-center justify-between">
            <div className="space-y-0.5">
              <Label htmlFor="email-updates">Product updates</Label>
              <p className="text-sm text-gray-500">
                Important updates about our service
              </p>
            </div>
            <Switch
              id="email-updates"
              checked={preferences.email_updates}
              onCheckedChange={(checked) => updatePreference('email_updates', checked)}
            />
          </div>

          <div className="flex items-center justify-between">
            <div className="space-y-0.5">
              <Label htmlFor="email-security">Security alerts</Label>
              <p className="text-sm text-gray-500">
                Important notifications about your account security
              </p>
            </div>
            <Switch
              id="email-security"
              checked={preferences.email_security}
              onCheckedChange={(checked) => updatePreference('email_security', checked)}
            />
          </div>
        </CardContent>
      </Card>

      {/* Push Notifications */}
      <Card>
        <CardHeader>
          <CardTitle>Push Notifications</CardTitle>
          <CardDescription>
            Manage your in-app notification preferences
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center justify-between">
            <div className="space-y-0.5">
              <Label htmlFor="push-enabled">Enable push notifications</Label>
              <p className="text-sm text-gray-500">
                Receive notifications in your browser
              </p>
            </div>
            <Switch
              id="push-enabled"
              checked={preferences.push_enabled}
              onCheckedChange={(checked) => updatePreference('push_enabled', checked)}
            />
          </div>

          {preferences.push_enabled && (
            <>
              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label htmlFor="push-comments">Comments</Label>
                  <p className="text-sm text-gray-500">
                    When someone comments on your content
                  </p>
                </div>
                <Switch
                  id="push-comments"
                  checked={preferences.push_comments}
                  onCheckedChange={(checked) => updatePreference('push_comments', checked)}
                />
              </div>

              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label htmlFor="push-mentions">Mentions</Label>
                  <p className="text-sm text-gray-500">
                    When someone mentions you
                  </p>
                </div>
                <Switch
                  id="push-mentions"
                  checked={preferences.push_mentions}
                  onCheckedChange={(checked) => updatePreference('push_mentions', checked)}
                />
              </div>

              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label htmlFor="push-updates">Updates</Label>
                  <p className="text-sm text-gray-500">
                    Product updates and announcements
                  </p>
                </div>
                <Switch
                  id="push-updates"
                  checked={preferences.push_updates}
                  onCheckedChange={(checked) => updatePreference('push_updates', checked)}
                />
              </div>
            </>
          )}
        </CardContent>
      </Card>

      <Button onClick={handleSave} disabled={loading}>
        {loading ? 'Saving...' : 'Save Preferences'}
      </Button>
    </div>
  )
}

// src/components/settings/appearance-settings.tsx
'use client'

import { useState } from 'react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Label } from '@/components/ui/label'
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Button } from '@/components/ui/button'
import { Icons } from '@/components/ui/icons'
import { useTheme } from 'next-themes'

export function AppearanceSettings() {
  const { theme, setTheme } = useTheme()
  const [font, setFont] = useState('inter')
  const [language, setLanguage] = useState('en')

  return (
    <div className="space-y-6">
      {/* Theme */}
      <Card>
        <CardHeader>
          <CardTitle>Theme</CardTitle>
          <CardDescription>
            Choose how the application looks to you
          </CardDescription>
        </CardHeader>
        <CardContent>
          <RadioGroup value={theme} onValueChange={setTheme}>
            <div className="flex items-center space-x-2">
              <RadioGroupItem value="light" id="light" />
              <Label htmlFor="light" className="flex items-center cursor-pointer">
                <Icons.sun className="h-4 w-4 mr-2" />
                Light
              </Label>
            </div>
            <div className="flex items-center space-x-2">
              <RadioGroupItem value="dark" id="dark" />
              <Label htmlFor="dark" className="flex items-center cursor-pointer">
                <Icons.moon className="h-4 w-4 mr-2" />
                Dark
              </Label>
            </div>
            <div className="flex items-center space-x-2">
              <RadioGroupItem value="system" id="system" />
              <Label htmlFor="system" className="flex items-center cursor-pointer">
                <Icons.laptop className="h-4 w-4 mr-2" />
                System
              </Label>
            </div>
          </RadioGroup>
        </CardContent>
      </Card>

      {/* Font */}
      <Card>
        <CardHeader>
          <CardTitle>Font</CardTitle>
          <CardDescription>
            Choose your preferred font family
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Select value={font} onValueChange={setFont}>
            <SelectTrigger>
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="inter">Inter</SelectItem>
              <SelectItem value="system">System Font</SelectItem>
              <SelectItem value="mono">Monospace</SelectItem>
            </SelectContent>
          </Select>
        </CardContent>
      </Card>

      {/* Language */}
      <Card>
        <CardHeader>
          <CardTitle>Language</CardTitle>
          <CardDescription>
            Choose your preferred language
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Select value={language} onValueChange={setLanguage}>
            <SelectTrigger>
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="en">English</SelectItem>
              <SelectItem value="es">Espaol</SelectItem>
              <SelectItem value="fr">Franais</SelectItem>
              <SelectItem value="de">Deutsch</SelectItem>
              <SelectItem value="pt">Portugus</SelectItem>
              <SelectItem value="ja"></SelectItem>
              <SelectItem value="zh"></SelectItem>
            </SelectContent>
          </Select>
        </CardContent>
      </Card>
    </div>
  )
}

// src/components/ui/switch.tsx
'use client'

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"
import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

// src/components/ui/radio-group.tsx
'use client'

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"
import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }



// src/lib/api-keys/service.ts
import { createClient } from '@/lib/supabase/server'
import crypto from 'crypto'

export interface ApiKey {
  id: string
  user_id: string
  name: string
  key: string
  last_used_at?: string
  expires_at?: string
  created_at: string
}

export class ApiKeyService {
  // Generate a secure API key
  static generateApiKey(): string {
    const prefix = 'sk_'
    const randomBytes = crypto.randomBytes(32)
    const key = randomBytes.toString('base64url')
    return `${prefix}${key}`
  }

  // Hash API key for storage
  static async hashApiKey(key: string): Promise<string> {
    const encoder = new TextEncoder()
    const data = encoder.encode(key)
    const hashBuffer = await crypto.subtle.digest('SHA-256', data)
    const hashArray = Array.from(new Uint8Array(hashBuffer))
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('')
    return hashHex
  }

  // Create new API key
  static async createApiKey(userId: string, name: string, expiresIn?: number) {
    const supabase = createClient()
    
    // Generate key
    const apiKey = this.generateApiKey()
    const hashedKey = await this.hashApiKey(apiKey)
    
    // Calculate expiry
    let expiresAt: string | null = null
    if (expiresIn) {
      const expiry = new Date()
      expiry.setDate(expiry.getDate() + expiresIn)
      expiresAt = expiry.toISOString()
    }

    // Store in database
    const { data, error } = await supabase
      .from('api_keys')
      .insert({
        user_id: userId,
        name,
        key: hashedKey,
        expires_at: expiresAt,
      })
      .select()
      .single()

    if (error) {
      throw new Error(error.message)
    }

    // Return the actual key (only shown once)
    return {
      ...data,
      key: apiKey, // Return unhashed key
    }
  }

  // List user's API keys
  static async listApiKeys(userId: string) {
    const supabase = createClient()
    
    const { data, error } = await supabase
      .from('api_keys')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })

    if (error) {
      throw new Error(error.message)
    }

    // Mask the keys for display
    return data.map(key => ({
      ...key,
      key: `${key.key.slice(0, 7)}...${key.key.slice(-4)}`,
    }))
  }

  // Delete API key
  static async deleteApiKey(keyId: string, userId: string) {
    const supabase = createClient()
    
    const { error } = await supabase
      .from('api_keys')
      .delete()
      .eq('id', keyId)
      .eq('user_id', userId)

    if (error) {
      throw new Error(error.message)
    }

    return { success: true }
  }

  // Validate API key
  static async validateApiKey(apiKey: string) {
    const supabase = createClient()
    const hashedKey = await this.hashApiKey(apiKey)
    
    const { data, error } = await supabase
      .from('api_keys')
      .select('*, user:users(*)')
      .eq('key', hashedKey)
      .single()

    if (error || !data) {
      return { valid: false }
    }

    // Check expiry
    if (data.expires_at && new Date(data.expires_at) < new Date()) {
      return { valid: false }
    }

    // Update last used
    await supabase
      .from('api_keys')
      .update({ last_used_at: new Date().toISOString() })
      .eq('id', data.id)

    return {
      valid: true,
      user: data.user,
      keyId: data.id,
    }
  }
}

// src/hooks/use-api-keys.ts
'use client'

import { useState, useEffect, useCallback } from 'react'
import { useAuth } from './use-auth'

interface ApiKey {
  id: string
  name: string
  key: string
  last_used_at?: string
  expires_at?: string
  created_at: string
}

export function useApiKeys() {
  const { user } = useAuth()
  const [apiKeys, setApiKeys] = useState<ApiKey[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    if (user) {
      fetchApiKeys()
    }
  }, [user])

  const fetchApiKeys = async () => {
    if (!user) return

    setLoading(true)
    try {
      const response = await fetch('/api/api-keys')
      const data = await response.json()

      if (response.ok) {
        setApiKeys(data)
      }
    } catch (error) {
      console.error('Failed to fetch API keys:', error)
    } finally {
      setLoading(false)
    }
  }

  const createApiKey = useCallback(async (name: string, expiresIn?: number) => {
    const response = await fetch('/api/api-keys', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, expiresIn }),
    })

    if (!response.ok) {
      throw new Error('Failed to create API key')
    }

    const newKey = await response.json()
    await fetchApiKeys()
    
    return newKey
  }, [])

  const deleteApiKey = useCallback(async (keyId: string) => {
    const response = await fetch(`/api/api-keys/${keyId}`, {
      method: 'DELETE',
    })

    if (!response.ok) {
      throw new Error('Failed to delete API key')
    }

    await fetchApiKeys()
  }, [])

  return {
    apiKeys,
    loading,
    createApiKey,
    deleteApiKey,
    refresh: fetchApiKeys,
  }
}

// src/app/api/api-keys/route.ts
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { ApiKeyService } from '@/lib/api-keys/service'
import { z } from 'zod'

const createApiKeySchema = z.object({
  name: z.string().min(1, 'Name is required'),
  expiresIn: z.number().optional(),
})

export async function GET() {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const apiKeys = await ApiKeyService.listApiKeys(user.id)
    return NextResponse.json(apiKeys)
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

export async function POST(request: Request) {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { name, expiresIn } = createApiKeySchema.parse(body)

    const apiKey = await ApiKeyService.createApiKey(user.id, name, expiresIn)
    return NextResponse.json(apiKey)
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors[0].message }, { status: 400 })
    }
    
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

// src/app/api/api-keys/[keyId]/route.ts
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { ApiKeyService } from '@/lib/api-keys/service'

interface Params {
  params: { keyId: string }
}

export async function DELETE(request: Request, { params }: Params) {
  try {
    const supabase = createClient()
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    await ApiKeyService.deleteApiKey(params.keyId, user.id)
    return NextResponse.json({ success: true })
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

// src/middleware/api-auth.ts
import { NextRequest, NextResponse } from 'next/server'
import { ApiKeyService } from '@/lib/api-keys/service'

export async function validateApiKeyMiddleware(request: NextRequest) {
  const authHeader = request.headers.get('authorization')
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return NextResponse.json({ error: 'Missing API key' }, { status: 401 })
  }

  const apiKey = authHeader.substring(7)
  const validation = await ApiKeyService.validateApiKey(apiKey)

  if (!validation.valid) {
    return NextResponse.json({ error: 'Invalid API key' }, { status: 401 })
  }

  // Add user info to request headers for downstream use
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set('x-user-id', validation.user.id)
  requestHeaders.set('x-user-email', validation.user.email)

  return NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  })
}



// src/app/api/admin/users/route.ts
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { AuthService } from '@/lib/auth/service'

export async function GET() {
  try {
    const supabase = createClient()
    
    // Check if user is admin
    const adminCheck = await AuthService.requireAdmin()
    
    // Get all users with their subscription status
    const { data: users, error } = await supabase
      .from('users')
      .select(`
        *,
        subscriptions(
          status,
          stripe_price_id
        )
      `)
      .order('created_at', { ascending: false })

    if (error) {
      throw new Error(error.message)
    }

    // Get stats
    const now = new Date()
    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1)

    const stats = {
      totalUsers: users.length,
      activeUsers: users.filter(u => {
        const lastSignIn = u.last_sign_in ? new Date(u.last_sign_in) : null
        return lastSignIn && (now.getTime() - lastSignIn.getTime()) < 30 * 24 * 60 * 60 * 1000
      }).length,
      paidUsers: users.filter(u => 
        u.subscriptions?.some((s: any) => s.status === 'ACTIVE')
      ).length,
      adminUsers: users.filter(u => ['ADMIN', 'SUPER_ADMIN'].includes(u.role)).length,
      newUsersThisMonth: users.filter(u => 
        new Date(u.created_at) >= startOfMonth
      ).length,
    }

    // Format users for frontend
    const formattedUsers = users.map(user => ({
      id: user.id,
      email: user.email,
      name: user.name,
      avatar_url: user.avatar_url,
      role: user.role,
      created_at: user.created_at,
      last_sign_in: user.last_sign_in_at,
      subscription: user.subscriptions?.[0] ? {
        status: user.subscriptions[0].status.toLowerCase(),
        plan: getPlanName(user.subscriptions[0].stripe_price_id),
      } : null,
    }))

    return NextResponse.json({
      users: formattedUsers,
      stats,
    })
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

function getPlanName(priceId: string | null): string {
  if (!priceId) return 'free'
  
  // Map price IDs to plan names
  if (priceId === process.env.NEXT_PUBLIC_STRIPE_PRO_PRICE_ID) {
    return 'pro'
  }
  
  return 'custom'
}

// src/app/api/admin/users/[userId]/role/route.ts
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { AuthService } from '@/lib/auth/service'
import { z } from 'zod'

interface Params {
  params: { userId: string }
}

const updateRoleSchema = z.object({
  role: z.enum(['USER', 'ADMIN', 'SUPER_ADMIN']),
})

export async function PATCH(request: Request, { params }: Params) {
  try {
    const supabase = createClient()
    
    // Check if user is admin
    const { role: adminRole } = await AuthService.requireAdmin()
    
    // Only super admins can create other super admins
    const body = await request.json()
    const { role } = updateRoleSchema.parse(body)
    
    if (role === 'SUPER_ADMIN' && adminRole !== 'SUPER_ADMIN') {
      return NextResponse.json(
        { error: 'Only super admins can create other super admins' },
        { status: 403 }
      )
    }

    // Update user role
    const { error } = await supabase
      .from('users')
      .update({ role })
      .eq('id', params.userId)

    if (error) {
      throw new Error(error.message)
    }

    return NextResponse.json({ success: true })
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: error.errors[0].message }, { status: 400 })
    }
    
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

// src/app/api/admin/users/[userId]/route.ts
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { AuthService } from '@/lib/auth/service'

interface Params {
  params: { userId: string }
}

export async function DELETE(request: Request, { params }: Params) {
  try {
    const supabase = createClient()
    
    // Check if user is admin
    await AuthService.requireAdmin()
    
    // Don't allow deleting self
    const { data: { user } } = await supabase.auth.getUser()
    if (user?.id === params.userId) {
      return NextResponse.json(
        { error: 'Cannot delete your own account' },
        { status: 400 }
      )
    }

    // Delete user (cascade will handle related records)
    const { error } = await supabase.auth.admin.deleteUser(params.userId)

    if (error) {
      throw new Error(error.message)
    }

    return NextResponse.json({ success: true })
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

// src/app/api/admin/users/[userId]/impersonate/route.ts
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { AuthService } from '@/lib/auth/service'
import { cookies } from 'next/headers'

interface Params {
  params: { userId: string }
}

export async function POST(request: Request, { params }: Params) {
  try {
    const supabase = createClient()
    
    // Check if user is admin
    const adminUser = await AuthService.requireAdmin()
    
    // Get target user
    const { data: targetUser, error } = await supabase
      .from('users')
      .select('*')
      .eq('id', params.userId)
      .single()

    if (error || !targetUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 })
    }

    // Store original user ID for reverting
    cookies().set('impersonating_from', adminUser.user.id, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60, // 1 hour
    })

    // Create impersonation session
    // Note: This is a simplified version. In production, you'd want to
    // create a proper impersonation token system
    cookies().set('impersonating_as', targetUser.id, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60, // 1 hour
    })

    return NextResponse.json({ success: true })
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

// src/app/api/admin/analytics/route.ts
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { AuthService } from '@/lib/auth/service'

export async function GET() {
  try {
    const supabase = createClient()
    
    // Check if user is admin
    await AuthService.requireAdmin()
    
    // Get date ranges
    const now = new Date()
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate())
    const thisWeek = new Date(today)
    thisWeek.setDate(today.getDate() - 7)
    const thisMonth = new Date(now.getFullYear(), now.getMonth(), 1)
    const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1)

    // Get user growth data
    const { data: userGrowth } = await supabase
      .from('users')
      .select('created_at')
      .gte('created_at', lastMonth.toISOString())
      .order('created_at')

    // Get revenue data
    const { data: revenueData } = await supabase
      .from('subscriptions')
      .select('created_at, stripe_price_id')
      .eq('status', 'ACTIVE')
      .gte('created_at', lastMonth.toISOString())
      .order('created_at')

    // Get activity data
    const { data: activityData } = await supabase
      .from('activity_logs')
      .select('created_at, action')
      .gte('created_at', thisWeek.toISOString())
      .order('created_at')

    // Process data for charts
    const analytics = {
      userGrowth: processGrowthData(userGrowth || []),
      revenue: processRevenueData(revenueData || []),
      activity: processActivityData(activityData || []),
      summary: {
        totalUsers: await getUserCount(supabase),
        activeUsers: await getActiveUserCount(supabase, thisMonth),
        totalRevenue: calculateTotalRevenue(revenueData || []),
        growthRate: calculateGrowthRate(userGrowth || []),
      },
    }

    return NextResponse.json(analytics)
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

function processGrowthData(data: any[]) {
  // Group by day and count
  const grouped = data.reduce((acc, item) => {
    const date = new Date(item.created_at).toISOString().split('T')[0]
    acc[date] = (acc[date] || 0) + 1
    return acc
  }, {})

  return Object.entries(grouped).map(([date, count]) => ({
    date,
    users: count,
  }))
}

function processRevenueData(data: any[]) {
  // Calculate monthly recurring revenue
  const proPriceMonthly = 29 // $29/month
  
  const grouped = data.reduce((acc, item) => {
    const date = new Date(item.created_at).toISOString().split('T')[0]
    acc[date] = (acc[date] || 0) + proPriceMonthly
    return acc
  }, {})

  return Object.entries(grouped).map(([date, revenue]) => ({
    date,
    revenue,
  }))
}

function processActivityData(data: any[]) {
  // Group by action type
  const grouped = data.reduce((acc, item) => {
    acc[item.action] = (acc[item.action] || 0) + 1
    return acc
  }, {})

  return Object.entries(grouped).map(([action, count]) => ({
    action,
    count,
  }))
}

async function getUserCount(supabase: any) {
  const { count } = await supabase
    .from('users')
    .select('*', { count: 'exact', head: true })
  
  return count || 0
}

async function getActiveUserCount(supabase: any, since: Date) {
  const { count } = await supabase
    .from('users')
    .select('*', { count: 'exact', head: true })
    .gte('last_sign_in_at', since.toISOString())
  
  return count || 0
}

function calculateTotalRevenue(subscriptions: any[]) {
  return subscriptions.length * 29 // $29/month per subscription
}

function calculateGrowthRate(users: any[]) {
  if (users.length < 2) return 0
  
  const now = new Date()
  const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)
  
  const recentUsers = users.filter(u => new Date(u.created_at) > thirtyDaysAgo).length
  const previousUsers = users.length - recentUsers
  
  if (previousUsers === 0) return 100
  
  return Math.round(((recentUsers - previousUsers) / previousUsers) * 100)
}





// src/app/(admin)/admin/analytics/page.tsx
'use client'

import { useEffect, useState } from 'react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Icons } from '@/components/ui/icons'
import { LineChart, Line, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts'
import { format } from 'date-fns'

interface AnalyticsData {
  userGrowth: Array<{ date: string; users: number }>
  revenue: Array<{ date: string; revenue: number }>
  activity: Array<{ action: string; count: number }>
  summary: {
    totalUsers: number
    activeUsers: number
    totalRevenue: number
    growthRate: number
  }
}

export default function AdminAnalyticsPage() {
  const [analytics, setAnalytics] = useState<AnalyticsData | null>(null)
  const [loading, setLoading] = useState(true)
  const [dateRange, setDateRange] = useState('30d')

  useEffect(() => {
    fetchAnalytics()
  }, [dateRange])

  const fetchAnalytics = async () => {
    setLoading(true)
    try {
      const response = await fetch(`/api/admin/analytics?range=${dateRange}`)
      const data = await response.json()
      
      if (response.ok) {
        setAnalytics(data)
      }
    } catch (error) {
      console.error('Failed to fetch analytics:', error)
    } finally {
      setLoading(false)
    }
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Icons.spinner className="h-8 w-8 animate-spin text-gray-400" />
      </div>
    )
  }

  if (!analytics) {
    return <div>Failed to load analytics</div>
  }

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold">Analytics</h1>
        <p className="text-gray-600 mt-2">
          Monitor your application's performance and growth
        </p>
      </div>

      {/* Summary Cards */}
      <div className="grid gap-4 md:grid-cols-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Total Users</CardTitle>
            <Icons.users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{analytics.summary.totalUsers.toLocaleString()}</div>
            <p className="text-xs text-muted-foreground">
              <span className={analytics.summary.growthRate >= 0 ? 'text-green-600' : 'text-red-600'}>
                {analytics.summary.growthRate >= 0 ? '+' : ''}{analytics.summary.growthRate}%
              </span> from last month
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Active Users</CardTitle>
            <Icons.activity className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{analytics.summary.activeUsers.toLocaleString()}</div>
            <p className="text-xs text-muted-foreground">
              Last 30 days
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Revenue</CardTitle>
            <Icons.dollarSign className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${analytics.summary.totalRevenue.toLocaleString()}
            </div>
            <p className="text-xs text-muted-foreground">
              Monthly recurring
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Conversion Rate</CardTitle>
            <Icons.trendingUp className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {analytics.summary.totalRevenue > 0 
                ? Math.round((analytics.summary.totalRevenue / 29 / analytics.summary.totalUsers) * 100)
                : 0}%
            </div>
            <p className="text-xs text-muted-foreground">
              Free to paid
            </p>
          </CardContent>
        </Card>
      </div>

      {/* User Growth Chart */}
      <Card>
        <CardHeader>
          <CardTitle>User Growth</CardTitle>
          <CardDescription>
            New user registrations over time
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={analytics.userGrowth}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis 
                  dataKey="date" 
                  tickFormatter={(date) => format(new Date(date), 'MMM d')}
                />
                <YAxis />
                <Tooltip 
                  labelFormatter={(date) => format(new Date(date), 'MMM d, yyyy')}
                />
                <Line 
                  type="monotone" 
                  dataKey="users" 
                  stroke="#8884d8" 
                  strokeWidth={2}
                  name="New Users"
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* Revenue Chart */}
      <Card>
        <CardHeader>
          <CardTitle>Revenue Growth</CardTitle>
          <CardDescription>
            Monthly recurring revenue over time
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="h-[300px]">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart data={analytics.revenue}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis 
                  dataKey="date" 
                  tickFormatter={(date) => format(new Date(date), 'MMM d')}
                />
                <YAxis tickFormatter={(value) => `$${value}`} />
                <Tooltip 
                  labelFormatter={(date) => format(new Date(date), 'MMM d, yyyy')}
                  formatter={(value: number) => [`$${value}`, 'Revenue']}
                />
                <Bar 
                  dataKey="revenue" 
                  fill="#82ca9d"
                  name="Revenue"
                />
              </BarChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* Activity Distribution */}
      <Card>
        <CardHeader>
          <CardTitle>User Activity</CardTitle>
          <CardDescription>
            Actions performed by users this week
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {analytics.activity.map((item) => (
              <div key={item.action} className="flex items-center justify-between">
                <div className="flex items-center space-x-2">
                  <div className="h-2 w-2 rounded-full bg-blue-500" />
                  <span className="text-sm font-medium capitalize">
                    {item.action.replace('_', ' ')}
                  </span>
                </div>
                <span className="text-sm text-gray-500">{item.count}</span>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
